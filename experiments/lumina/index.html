<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lumina</title>
    <link rel="icon" type="image/svg+xml" href="../../favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        @view-transition { navigation: auto; }
        :focus-visible { outline: 2px solid rgba(255,255,255,0.5); outline-offset: 2px; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #000;
            color: #fff;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            cursor: none;
        }

        /* ═══ VIDEO ═══ */
        .video-layer {
            position: fixed; inset: 0; z-index: 0;
            overflow: hidden;
        }
        .video-layer video {
            width: 100%; height: 100%; object-fit: cover;
        }

        /* ═══ OVERLAYS ═══ */
        .dark-overlay {
            position: fixed; inset: 0; z-index: 1;
            background: #000; opacity: 0.3;
            pointer-events: none;
            transition: opacity 1.5s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #canvas {
            position: fixed; inset: 0; z-index: 2;
        }
        .vignette {
            position: fixed; inset: 0; z-index: 3;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
        }

        /* ═══ FLASH ═══ */
        .flash {
            position: fixed; inset: 0; z-index: 4;
            background: #fff; opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease-out;
        }
        .flash.pop { opacity: 0.12; transition: none; }

        /* ═══ CHAPTERS ═══ */
        .chapter {
            position: fixed; inset: 0; z-index: 5;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            text-align: center;
            padding: 0 max(24px, env(safe-area-inset-left, 24px));
            pointer-events: none;
            opacity: 0;
            transform: translateY(30px) scale(0.97);
            transition: opacity 0.7s cubic-bezier(0.16, 1, 0.3, 1),
                        transform 0.7s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .chapter.active {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .chapter.exit {
            opacity: 0;
            transform: translateY(-24px) scale(1.02);
        }

        .chapter-overline {
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.35);
            margin-bottom: 20px;
        }

        .chapter-display {
            font-size: clamp(64px, 15vw, 200px);
            font-weight: 900;
            letter-spacing: -0.05em;
            line-height: 0.88;
            background: linear-gradient(160deg, #fff 20%, rgba(255,255,255,0.5) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .chapter-num {
            font-size: clamp(11px, 1.2vw, 13px);
            font-weight: 600;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.3);
            margin-bottom: 18px;
        }

        .chapter-title {
            font-size: clamp(48px, 10vw, 120px);
            font-weight: 900;
            letter-spacing: -0.04em;
            line-height: 0.92;
            background: linear-gradient(160deg, #fff 10%, rgba(255,255,255,0.6) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 24px;
        }

        .chapter-text {
            font-size: clamp(14px, 1.6vw, 18px);
            font-weight: 300;
            line-height: 1.75;
            color: rgba(255,255,255,0.5);
            max-width: 440px;
        }

        .chapter-instruction {
            margin-top: 40px;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: 0.08em;
            color: rgba(255,255,255,0.4);
            animation: pulse-instruction 2s ease-in-out infinite;
        }
        @keyframes pulse-instruction {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .chapter-final {
            font-size: clamp(11px, 1vw, 13px);
            font-weight: 400;
            color: rgba(255,255,255,0.25);
            margin-top: 32px;
            letter-spacing: 0.04em;
        }

        /* ═══ HUD ═══ */
        .hud {
            position: fixed;
            top: max(20px, env(safe-area-inset-top, 20px));
            right: max(20px, env(safe-area-inset-right, 20px));
            z-index: 10;
            display: flex; align-items: center; gap: 10px;
            padding: 8px 18px 8px 12px;
            background: rgba(255,255,255,0.06);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 100px;
            transform: translateY(-10px);
            opacity: 0;
            transition: opacity 0.6s, transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .hud.visible { opacity: 1; transform: translateY(0); }

        .lumen-icon {
            width: 14px; height: 14px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,200,80,0.9), rgba(255,200,80,0));
        }
        .lumen-value {
            font-size: 15px; font-weight: 700;
            font-variant-numeric: tabular-nums;
            color: rgba(255,255,255,0.9);
            min-width: 18px;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .lumen-value.bump { transform: scale(1.5); }
        .lumen-label {
            font-size: 8px; font-weight: 600;
            letter-spacing: 0.14em;
            color: rgba(255,255,255,0.25);
            text-transform: uppercase;
        }

        /* ═══ TOASTS ═══ */
        .toast-container {
            position: fixed;
            top: max(70px, calc(env(safe-area-inset-top, 0px) + 64px));
            right: max(20px, env(safe-area-inset-right, 20px));
            z-index: 20;
            display: flex; flex-direction: column; gap: 8px;
            pointer-events: none;
        }
        .toast {
            padding: 10px 18px;
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            transform: translateX(130%);
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1),
                        opacity 0.5s;
        }
        .toast.show { transform: translateX(0); opacity: 1; }
        .toast-title {
            font-size: 12px; font-weight: 700;
            color: rgba(255,200,80,0.95);
            letter-spacing: -0.01em;
        }
        .toast-desc {
            font-size: 10px; font-weight: 400;
            color: rgba(255,255,255,0.35);
            margin-top: 2px;
        }

        /* ═══ PROGRESS ═══ */
        .progress-track {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0);
            left: 0; right: 0;
            height: 3px;
            background: rgba(255,255,255,0.04);
            z-index: 10;
        }
        .progress-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, rgba(255,200,80,0.6), rgba(255,80,160,0.6));
            transition: width 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* ═══ NAV ═══ */
        .exp-nav {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom, 20px));
            left: 50%; transform: translateX(-50%);
            z-index: 100;
            display: flex; gap: 2px; padding: 4px;
            border-radius: 14px;
            background: rgba(255,255,255,0.06);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.08);
        }
        .exp-nav a {
            display: flex; align-items: center; justify-content: center;
            width: 38px; height: 38px; border-radius: 10px;
            text-decoration: none; color: rgba(255,255,255,0.5);
            transition: background 0.2s, color 0.2s;
        }
        .exp-nav a:hover { background: rgba(255,255,255,0.1); color: #fff; }

        /* ═══ SOUND TOGGLE ═══ */
        .sound-toggle {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom, 20px));
            right: max(20px, env(safe-area-inset-right, 20px));
            z-index: 100;
            width: 38px; height: 38px;
            border-radius: 10px;
            background: rgba(255,255,255,0.06);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.3);
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .sound-toggle:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .sound-toggle.active { color: rgba(255,255,255,0.7); }
        .sound-toggle .icon-off { display: block; }
        .sound-toggle .icon-on { display: none; }
        .sound-toggle.active .icon-off { display: none; }
        .sound-toggle.active .icon-on { display: block; }

        /* ═══ RESPONSIVE ═══ */
        @media (max-width: 480px) {
            .chapter { padding: 0 20px; }
            .chapter-text { max-width: 320px; }
        }
        @media (prefers-reduced-motion: reduce) {
            .chapter { transition: opacity 0.3s; }
            .chapter-instruction { animation: none; opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="video-layer">
        <video id="bgVideo" muted autoplay loop playsinline disablePictureInPicture preload="auto" aria-label="Background ambient video">
            <source src="https://storage.googleapis.com/myproject-public-assets/ddn/videos/test/claude-pretty-ugvuda.mp4" type="video/mp4">
        </video>
    </div>

    <div class="dark-overlay" id="darkOverlay"></div>
    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div class="flash" id="flash"></div>

    <!-- ═══ STORY CHAPTERS ═══ -->
    <div class="chapter active" id="c0">
        <p class="chapter-overline">An interactive light experience</p>
        <h1 class="chapter-display">Lumina</h1>
        <p class="chapter-instruction" id="instruction">Move through the light</p>
    </div>

    <div class="chapter" id="c1">
        <p class="chapter-num">I</p>
        <h2 class="chapter-title">First<br>Spark</h2>
        <p class="chapter-text">Every great thing begins with a single point of light &mdash; small, impossibly bright, full of everything it could become.</p>
    </div>

    <div class="chapter" id="c2">
        <p class="chapter-num">II</p>
        <h2 class="chapter-title">Chain<br>Reaction</h2>
        <p class="chapter-text">One catches two. Two catches four.<br>Light doesn't add &mdash; it multiplies.</p>
    </div>

    <div class="chapter" id="c3">
        <p class="chapter-num">III</p>
        <h2 class="chapter-title">Full<br>Spectrum</h2>
        <p class="chapter-text">Every color racing through you at once &mdash;<br>not choosing, not filtering.<br>Just blazing.</p>
    </div>

    <div class="chapter" id="c4">
        <p class="chapter-num">IV</p>
        <h2 class="chapter-title">Super-<br>nova</h2>
        <p class="chapter-text">The moment right before everything<br>becomes impossibly, radiantly bright &mdash;<br>that's where the magic lives.</p>
    </div>

    <div class="chapter" id="c5">
        <p class="chapter-num">V</p>
        <h2 class="chapter-title">Pure<br>Light</h2>
        <p class="chapter-text">You didn't collect the light.<br>You reminded it where to go.</p>
    </div>

    <div class="chapter" id="c6">
        <h2 class="chapter-title" style="font-size:clamp(52px,12vw,140px)">&infin;</h2>
        <p class="chapter-text">Every photon you touched is still moving,<br>still carrying the shape of this moment<br>to the edge of everything.</p>
        <p class="chapter-final">Lumina complete</p>
    </div>

    <!-- ═══ HUD ═══ -->
    <div class="hud" id="hud">
        <div class="lumen-icon"></div>
        <span class="lumen-value" id="lumenValue">0</span>
        <span class="lumen-label">lumens</span>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <div class="progress-track">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <button class="sound-toggle" id="soundToggle" title="Toggle sound" aria-label="Toggle sound" aria-pressed="false">
        <svg class="icon-off" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        <svg class="icon-on" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
    </button>


    <script>
    (function() {
        'use strict';
        /* Video override via ?v= */
        var _p = new URLSearchParams(location.search); var _cv = _p.get('v');
        if (_cv) { document.querySelectorAll('video source').forEach(function(s) { s.setAttribute('src', _cv); s.parentElement.load(); }); }

        /* ═══════════════════════════════════════
           SOUND ENGINE (Web Audio API synthesis)
           ═══════════════════════════════════════ */
        let audioCtx = null;
        let masterGain = null;
        let droneGain = null;
        let soundEnabled = false;
        const soundToggleBtn = document.getElementById('soundToggle');

        function initAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) { return; }
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0;
            masterGain.connect(audioCtx.destination);

            /* Ambient drone: 3 detuned oscillators through lowpass */
            droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.12;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 1;
            droneGain.connect(filter);
            filter.connect(masterGain);

            const freqs = [55, 55.3, 82.4]; /* A1, slightly detuned, E2 */
            freqs.forEach(function(f) {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = f;
                osc.connect(droneGain);
                osc.start();
            });

            /* Slow LFO on filter for movement */
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.value = 0.15;
            lfoGain.gain.value = 150;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start();
        }

        function playCollectSound(ci) {
            if (!audioCtx || !soundEnabled) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine';
            /* Map color index to pentatonic scale note */
            const notes = [523, 587, 659, 784, 880, 988, 1047, 1175];
            osc.frequency.value = notes[ci % notes.length] * (0.95 + Math.random() * 0.1);
            g.gain.setValueAtTime(0.08, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            osc.connect(g);
            g.connect(masterGain);
            osc.start(now);
            osc.stop(now + 0.4);
        }

        function playChapterSound() {
            if (!audioCtx || !soundEnabled) return;
            const now = audioCtx.currentTime;
            const notes = [523, 659, 784]; /* C5, E5, G5 arpeggio */
            notes.forEach(function(f, i) {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = f;
                g.gain.setValueAtTime(0, now + i * 0.12);
                g.gain.linearRampToValueAtTime(0.06, now + i * 0.12 + 0.05);
                g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.6);
                osc.connect(g);
                g.connect(masterGain);
                osc.start(now + i * 0.12);
                osc.stop(now + i * 0.12 + 0.6);
            });
        }

        soundToggleBtn.addEventListener('click', function() {
            initAudio();
            soundEnabled = !soundEnabled;
            soundToggleBtn.classList.toggle('active', soundEnabled);
            soundToggleBtn.setAttribute('aria-pressed', String(soundEnabled));
            if (audioCtx) {
                masterGain.gain.linearRampToValueAtTime(
                    soundEnabled ? 1 : 0,
                    audioCtx.currentTime + 0.3
                );
                if (audioCtx.state === 'suspended') audioCtx.resume().catch(function(){});
            }
        });

        /* ═══════════════════════════════════════
           CONFIG
           ═══════════════════════════════════════ */

        const THRESHOLDS = [0, 2, 8, 18, 35, 55, 80];

        const ACHIEVEMENTS = [
            { at: 1,  title: 'First Light',     desc: 'Let there be light' },
            { at: 5,  title: 'Spark',            desc: 'You\'re glowing' },
            { at: 15, title: 'Chain Reaction',   desc: 'Can\'t stop the light' },
            { at: 30, title: 'Radiant',          desc: 'The screen feels it' },
            { at: 50, title: 'Supernova',        desc: 'Everything is light' },
            { at: 80, title: 'Transcendent',     desc: 'You became the light' }
        ];

        const COLORS = [
            [255, 80, 180],   // hot pink
            [80, 160, 255],   // sky blue
            [255, 210, 60],   // golden
            [60, 255, 200],   // mint
            [200, 120, 255],  // violet
            [255, 140, 70],   // tangerine
            [120, 255, 120],  // lime
            [255, 100, 100]   // warm red
        ];

        /* ═══════════════════════════════════════
           STATE
           ═══════════════════════════════════════ */

        let lumens = 0;
        let activeChapter = 0;
        let combo = 0;
        let lastCollectTime = 0;
        let mx = -500, my = -500;
        let W, H;
        let maxOrbs = 14;
        let spawnInterval = 600;
        let spawnTimer = 0;
        let magnetRadius = 160;
        let autoCollectRadius = 55;

        /* ═══════════════════════════════════════
           DOM
           ═══════════════════════════════════════ */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const darkOverlay = document.getElementById('darkOverlay');
        const flashEl = document.getElementById('flash');
        const lumenValueEl = document.getElementById('lumenValue');
        const hudEl = document.getElementById('hud');
        const toastContainer = document.getElementById('toastContainer');
        const progressFill = document.getElementById('progressFill');
        const instructionEl = document.getElementById('instruction');
        const chapters = [];
        for (let i = 0; i <= 6; i++) chapters.push(document.getElementById('c' + i));

        /* ═══════════════════════════════════════
           CANVAS SETUP
           ═══════════════════════════════════════ */

        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        resize();
        window.addEventListener('resize', resize, { passive: true });

        /* ═══════════════════════════════════════
           GLOW TEXTURES (pre-rendered)
           ═══════════════════════════════════════ */

        function makeGlow(r, g, b, rad) {
            const c = document.createElement('canvas');
            c.width = c.height = rad * 2;
            const x = c.getContext('2d');
            const gr = x.createRadialGradient(rad, rad, 0, rad, rad, rad);
            gr.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',1)');
            gr.addColorStop(0.15, 'rgba(' + r + ',' + g + ',' + b + ',0.6)');
            gr.addColorStop(0.4, 'rgba(' + r + ',' + g + ',' + b + ',0.15)');
            gr.addColorStop(1, 'rgba(' + r + ',' + g + ',' + b + ',0)');
            x.fillStyle = gr;
            x.fillRect(0, 0, c.width, c.height);
            return c;
        }

        const glows = COLORS.map(function(c) { return makeGlow(c[0], c[1], c[2], 100); });
        const cursorGlow = makeGlow(255, 255, 255, 120);

        /* ═══════════════════════════════════════
           PARTICLES
           ═══════════════════════════════════════ */

        /* — Ambient — */
        const ambients = [];
        for (let i = 0; i < 60; i++) {
            ambients.push({
                x: Math.random() * 2000,
                y: Math.random() * 2000,
                vx: (Math.random() - 0.5) * 0.4,
                vy: (Math.random() - 0.5) * 0.4,
                r: 0.6 + Math.random() * 2.5,
                a: 0.1 + Math.random() * 0.2,
                phase: Math.random() * 6.28,
                ci: Math.floor(Math.random() * COLORS.length)
            });
        }

        /* — Trails (follow cursor) — */
        const trails = [];

        /* — Collectible Orbs — */
        const orbs = [];

        function spawnOrb() {
            if (orbs.length >= maxOrbs) return;
            const o = {
                x: 0, y: 0, vx: 0, vy: 0,
                radius: 14 + Math.random() * 14,
                ci: Math.floor(Math.random() * COLORS.length),
                phase: Math.random() * 6.28,
                alive: true,
                collecting: false,
                ct: 0, born: performance.now()
            };
            const side = Math.floor(Math.random() * 4);
            const speed = 0.5 + Math.random() * 0.8;
            const drift = (Math.random() - 0.5) * 0.5;
            if (side === 0)      { o.x = -50; o.y = Math.random() * H; o.vx = speed; o.vy = drift; }
            else if (side === 1) { o.x = W + 50; o.y = Math.random() * H; o.vx = -speed; o.vy = drift; }
            else if (side === 2) { o.x = Math.random() * W; o.y = -50; o.vx = drift; o.vy = speed; }
            else                 { o.x = Math.random() * W; o.y = H + 50; o.vx = drift; o.vy = -speed; }
            orbs.push(o);
        }

        for (let i = 0; i < 8; i++) spawnOrb();

        /* — Burst particles — */
        const bursts = [];

        function emitBurst(x, y, ci, power) {
            const n = 10 + Math.floor(Math.random() * 8 + power * 3);
            for (let i = 0; i < n; i++) {
                const angle = (6.28 / n) * i + Math.random() * 0.5;
                const speed = 2 + Math.random() * 5 + power;
                bursts.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: 1.5 + Math.random() * 4,
                    alpha: 1.2, ci: ci
                });
            }
        }

        /* — Pulse rings — */
        const pulses = [];

        /* — Floating score texts — */
        const floats = [];

        /* ═══════════════════════════════════════
           SCREEN EFFECTS
           ═══════════════════════════════════════ */

        function screenFlash() {
            flashEl.classList.add('pop');
            setTimeout(function() { flashEl.classList.remove('pop'); }, 20);
        }

        /* ═══════════════════════════════════════
           INPUT
           ═══════════════════════════════════════ */

        document.addEventListener('mousemove', function(e) {
            mx = e.clientX; my = e.clientY;
        }, { passive: true });

        document.addEventListener('touchmove', function(e) {
            if (e.touches.length) { mx = e.touches[0].clientX; my = e.touches[0].clientY; }
        }, { passive: true });

        document.addEventListener('touchstart', function(e) {
            if (e.touches.length) {
                mx = e.touches[0].clientX;
                my = e.touches[0].clientY;
            }
        }, { passive: true });

        /* Click causes a shockwave that collects everything nearby */
        document.addEventListener('click', function(e) {
            pulses.push({ x: e.clientX, y: e.clientY, radius: 0, alpha: 0.55 });
            /* Shockwave collects in a large radius */
            for (let i = 0; i < orbs.length; i++) {
                const o = orbs[i];
                if (o.collecting || !o.alive) continue;
                const dx = e.clientX - o.x, dy = e.clientY - o.y;
                if (Math.sqrt(dx * dx + dy * dy) < 200) {
                    collectOrb(o);
                }
            }
        });

        function collectOrb(o) {
            if (o.collecting) return;
            o.collecting = true;
            o.ct = 0;

            const now = performance.now();
            if (now - lastCollectTime < 2000) { combo++; }
            else { combo = 1; }
            lastCollectTime = now;

            const points = combo;
            const ci = o.ci;

            setTimeout(function() {
                if (!o.alive) return;
                emitBurst(o.x, o.y, ci, Math.min(combo, 5));
                screenFlash();
                playCollectSound(ci);
                o.alive = false;
                lumens += points;
                onLumensChange();
                floats.push({
                    x: o.x, y: o.y - 10,
                    text: '+' + points,
                    alpha: 1.5, vy: -1.2,
                    scale: 1 + Math.min(combo * 0.15, 1)
                });

                /* Chain reaction — nearby orbs get pulled in too */
                if (combo >= 2) {
                    for (let j = 0; j < orbs.length; j++) {
                        const oo = orbs[j];
                        if (oo === o || oo.collecting || !oo.alive) continue;
                        const ddx = o.x - oo.x, ddy = o.y - oo.y;
                        if (Math.sqrt(ddx * ddx + ddy * ddy) < 120 + combo * 15) {
                            setTimeout(function(target) {
                                return function() { collectOrb(target); };
                            }(oo), 80 + Math.random() * 120);
                        }
                    }
                }
            }, 150);
        }

        /* ═══════════════════════════════════════
           GAME STATE
           ═══════════════════════════════════════ */

        function onLumensChange() {
            lumenValueEl.textContent = lumens;
            lumenValueEl.classList.add('bump');
            setTimeout(function() { lumenValueEl.classList.remove('bump'); }, 180);

            if (lumens >= 1) {
                hudEl.classList.add('visible');
                instructionEl.style.display = 'none';
            }

            /* Dark overlay fades quickly */
            const overlayAlpha = Math.max(0.02, 0.3 - (lumens / 80) * 0.28);
            darkOverlay.style.opacity = overlayAlpha;

            /* Difficulty + reward scaling */
            if (lumens >= 40)      { maxOrbs = 22; spawnInterval = 300; magnetRadius = 220; autoCollectRadius = 80; }
            else if (lumens >= 20) { maxOrbs = 18; spawnInterval = 400; magnetRadius = 190; autoCollectRadius = 70; }
            else if (lumens >= 8)  { maxOrbs = 16; spawnInterval = 500; magnetRadius = 175; autoCollectRadius = 60; }

            updateProgress();
            checkChapters();
            checkAchievements();
        }

        function updateProgress() {
            const next = activeChapter + 1;
            if (next >= THRESHOLDS.length) { progressFill.style.width = '100%'; return; }
            const lo = THRESHOLDS[activeChapter];
            const hi = THRESHOLDS[next];
            const p = Math.min((lumens - lo) / (hi - lo), 1);
            progressFill.style.width = (p * 100) + '%';
        }

        function checkChapters() {
            for (let i = THRESHOLDS.length - 1; i >= 0; i--) {
                if (lumens >= THRESHOLDS[i] && i > activeChapter) {
                    transitionTo(i);
                    break;
                }
            }
        }

        function transitionTo(idx) {
            if (idx === activeChapter) return;
            playChapterSound();
            const prev = chapters[activeChapter];
            prev.classList.remove('active');
            prev.classList.add('exit');
            activeChapter = idx;
            const captured = idx;
            setTimeout(function() {
                prev.classList.remove('exit');
                chapters[captured].classList.add('active');
                updateProgress();
            }, 500);
        }

        function checkAchievements() {
            for (let i = 0; i < ACHIEVEMENTS.length; i++) {
                const a = ACHIEVEMENTS[i];
                if (lumens >= a.at && !a.shown) {
                    a.shown = true;
                    showToast(a.title, a.desc);
                }
            }
        }

        function showToast(title, desc) {
            const el = document.createElement('div');
            el.className = 'toast';
            el.innerHTML = '<div class="toast-title">' + title + '</div><div class="toast-desc">' + desc + '</div>';
            toastContainer.appendChild(el);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() { el.classList.add('show'); });
            });
            setTimeout(function() {
                el.classList.remove('show');
                setTimeout(function() { el.remove(); }, 500);
            }, 3000);
        }

        /* ═══════════════════════════════════════
           RENDER LOOP
           ═══════════════════════════════════════ */

        let lastTime = performance.now();

        function frame(now) {
            const dt = Math.min(now - lastTime, 50);
            lastTime = now;

            ctx.clearRect(0, 0, W, H);

            /* — Spawn orbs — */
            spawnTimer += dt;
            if (spawnTimer > spawnInterval) { spawnOrb(); spawnTimer = 0; }

            /* — Cursor trail — */
            if (mx > 0 && my > 0) {
                trails.push({
                    x: mx, y: my,
                    alpha: 0.5, r: 3 + Math.random() * 3,
                    ci: Math.floor(Math.random() * COLORS.length)
                });
                if (trails.length > 30) trails.shift();
            }

            ctx.globalCompositeOperation = 'lighter';

            /* — Cursor glow — */
            if (mx > 0 && my > 0) {
                const gs = 50 + lumens * 0.4;
                ctx.globalAlpha = 0.12 + Math.min(lumens * 0.002, 0.12);
                ctx.drawImage(cursorGlow, mx - gs, my - gs, gs * 2, gs * 2);
                ctx.globalAlpha = 1;
            }

            /* — Trails — */
            for (let i = trails.length - 1; i >= 0; i--) {
                const tr = trails[i];
                tr.alpha -= 0.025;
                if (tr.alpha <= 0) { trails.splice(i, 1); continue; }
                ctx.globalAlpha = tr.alpha * 0.4;
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, tr.r, 0, 6.28);
                const tc = COLORS[tr.ci];
                ctx.fillStyle = 'rgba(' + tc[0] + ',' + tc[1] + ',' + tc[2] + ',1)';
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            /* — Ambient particles — */
            for (let i = 0; i < ambients.length; i++) {
                const a = ambients[i];
                a.x += a.vx; a.y += a.vy;
                a.phase += 0.012;
                if (a.x < -10) a.x = W + 10;
                if (a.x > W + 10) a.x = -10;
                if (a.y < -10) a.y = H + 10;
                if (a.y > H + 10) a.y = -10;

                /* Ambient particles react to cursor */
                if (mx > 0) {
                    const adx = mx - a.x, ady = my - a.y;
                    const adist = Math.sqrt(adx * adx + ady * ady);
                    if (adist < 180 && adist > 1) {
                        a.vx += (adx / adist) * 0.015;
                        a.vy += (ady / adist) * 0.015;
                    }
                    a.vx *= 0.99; a.vy *= 0.99;
                }

                const brightness = a.a * (0.5 + 0.5 * Math.sin(a.phase));
                ctx.globalAlpha = brightness;
                const ac = COLORS[a.ci];
                ctx.beginPath();
                ctx.arc(a.x, a.y, a.r, 0, 6.28);
                ctx.fillStyle = 'rgba(' + ac[0] + ',' + ac[1] + ',' + ac[2] + ',1)';
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            /* — Collectible orbs — */
            for (let i = orbs.length - 1; i >= 0; i--) {
                const o = orbs[i];
                if (!o.alive) { orbs.splice(i, 1); continue; }

                if (o.collecting) {
                    o.x += (mx - o.x) * 0.2;
                    o.y += (my - o.y) * 0.2;
                    o.ct += dt;
                } else {
                    /* Magnetic pull toward cursor */
                    const dx = mx - o.x, dy = my - o.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < magnetRadius && dist > 1) {
                        let force = (magnetRadius - dist) / magnetRadius;
                        force = force * force * 1.8;
                        o.vx += (dx / dist) * force;
                        o.vy += (dy / dist) * force;
                    }

                    /* Auto-collect on proximity */
                    if (dist < autoCollectRadius) {
                        collectOrb(o);
                    }

                    o.vx *= 0.97; o.vy *= 0.97;
                    o.x += o.vx; o.y += o.vy;

                    if (o.x < -80) o.x = W + 80;
                    if (o.x > W + 80) o.x = -80;
                    if (o.y < -80) o.y = H + 80;
                    if (o.y > H + 80) o.y = -80;
                }

                const pulse = 1 + 0.25 * Math.sin(now * 0.004 + o.phase);
                let dr = o.radius * pulse;
                /* Entrance scale */
                const age = Math.min((now - o.born) / 400, 1);
                dr *= age;

                const tex = glows[o.ci];
                ctx.globalAlpha = (o.collecting ? Math.max(0, 1 - o.ct / 150) : 0.9) * age;
                ctx.drawImage(tex, o.x - dr * 3, o.y - dr * 3, dr * 6, dr * 6);
                /* Bright core */
                ctx.globalAlpha = (o.collecting ? Math.max(0, 1 - o.ct / 120) : 1) * age;
                ctx.beginPath();
                ctx.arc(o.x, o.y, dr * 0.4, 0, 6.28);
                ctx.fillStyle = 'rgba(' + COLORS[o.ci][0] + ',' + COLORS[o.ci][1] + ',' + COLORS[o.ci][2] + ',1)';
                ctx.fill();
                /* White-hot center */
                ctx.globalAlpha = (o.collecting ? Math.max(0, 1 - o.ct / 100) : 0.7) * age;
                ctx.beginPath();
                ctx.arc(o.x, o.y, dr * 0.15, 0, 6.28);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            /* — Burst particles — */
            for (let i = bursts.length - 1; i >= 0; i--) {
                const b = bursts[i];
                b.x += b.vx; b.y += b.vy;
                b.vx *= 0.94; b.vy *= 0.94;
                b.alpha -= 0.022;
                if (b.alpha <= 0) { bursts.splice(i, 1); continue; }
                ctx.globalAlpha = Math.min(b.alpha, 1);
                const tex = glows[b.ci];
                ctx.drawImage(tex, b.x - b.r * 3, b.y - b.r * 3, b.r * 6, b.r * 6);
            }
            ctx.globalAlpha = 1;

            /* — Pulse rings — */
            for (let i = pulses.length - 1; i >= 0; i--) {
                const p = pulses[i];
                p.radius += 4;
                p.alpha -= 0.01;
                if (p.alpha <= 0) { pulses.splice(i, 1); continue; }
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, 6.28);
                ctx.strokeStyle = 'rgba(255,255,255,' + Math.min(p.alpha, 1) + ')';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.globalCompositeOperation = 'lighter';
            }

            /* — Floating score texts — */
            ctx.globalCompositeOperation = 'source-over';
            for (let i = floats.length - 1; i >= 0; i--) {
                const f = floats[i];
                f.y += f.vy;
                f.alpha -= 0.018;
                if (f.alpha <= 0) { floats.splice(i, 1); continue; }
                ctx.globalAlpha = Math.min(f.alpha, 1);
                const fs = Math.round(16 * (f.scale || 1));
                ctx.font = '800 ' + fs + 'px Inter, sans-serif';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(f.text, f.x, f.y);
            }

            /* — Combo indicator — */
            if (combo > 1 && now - lastCollectTime < 2000) {
                const ca = Math.min(1, (2000 - (now - lastCollectTime)) / 600);
                ctx.globalAlpha = ca * 0.9;
                const comboSize = Math.min(16 + combo * 2, 32);
                ctx.font = '900 ' + comboSize + 'px Inter, sans-serif';
                ctx.fillStyle = 'rgba(255,220,80,1)';
                ctx.textAlign = 'center';
                ctx.fillText('\u00d7' + combo, mx + 28, my - 28);

                /* Combo ring */
                const ringProgress = 1 - (now - lastCollectTime) / 2000;
                ctx.globalAlpha = ca * 0.35;
                ctx.beginPath();
                ctx.arc(mx, my, 25 + combo * 2, -1.57, -1.57 + ringProgress * 6.28);
                ctx.strokeStyle = 'rgba(255,220,80,1)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(frame);
        }

        /* ═══════════════════════════════════════
           INIT
           ═══════════════════════════════════════ */

        chapters[0].classList.add('active');
        requestAnimationFrame(frame);

        /* Smooth loop fade — rAF-based, self-terminates when paused */
        const bgVid = document.getElementById('bgVideo');
        (function() {
            var fadeDur = 0.5;
            function tick() {
                if (bgVid.paused) return;
                if (bgVid.duration) {
                    var rem = bgVid.duration - bgVid.currentTime;
                    var o = 1;
                    if (rem < fadeDur) o = rem / fadeDur;
                    else if (bgVid.currentTime < fadeDur) o = Math.min(bgVid.currentTime / fadeDur, 1);
                    bgVid.style.opacity = o;
                }
                requestAnimationFrame(tick);
            }
            bgVid.addEventListener('play', function() { requestAnimationFrame(tick); });
        })();

    /* ─── Service Worker ─── */
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/MADvids/sw.js').catch(function(){});
    }

    })();
    </script>
    <script src="/nav.js"></script>
</body>
</html>
