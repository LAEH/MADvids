<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluid Verse — MADvids</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            user-select: none;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .glass-nav {
            position: fixed;
            top: max(16px, env(safe-area-inset-top, 16px));
            left: max(16px, env(safe-area-inset-left, 16px));
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .glass-nav a {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .glass-nav a:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff;
        }

        .controls-panel {
            position: fixed;
            bottom: max(16px, env(safe-area-inset-bottom, 16px));
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 6px;
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
        }

        .ctrl-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 15px;
            font-family: inherit;
        }

        .ctrl-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: rgba(255, 255, 255, 0.9);
        }

        .ctrl-btn.active {
            background: rgba(255, 255, 255, 0.16);
            border-color: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: clamp(14px, 2.5vw, 18px);
            font-weight: 300;
            letter-spacing: 3px;
            pointer-events: none;
            transition: opacity 2s ease;
            text-align: center;
            text-transform: uppercase;
        }

        .hint.hidden { opacity: 0; }

        .title-overlay {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom, 20px));
            right: max(20px, env(safe-area-inset-right, 20px));
            z-index: 50;
            pointer-events: none;
        }

        .title-overlay h1 {
            font-size: 11px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.2);
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .glass-nav { top: 12px; left: 12px; }
            .controls-panel { bottom: 12px; }
        }

        @media (prefers-reduced-motion: reduce) {
            .hint { transition: none; }
        }
    </style>
</head>
<body>
    <canvas id="fluid"></canvas>

    <nav class="glass-nav">
        <a href="/MADvids/">&#8592; Back</a>
    </nav>

    <div class="hint" id="hint">Move to paint with light</div>

    <div class="controls-panel">
        <button class="ctrl-btn" id="btnReset" title="Reset fluid">&#8634;</button>
        <button class="ctrl-btn active" id="btnBloom" title="Toggle bloom">&#10022;</button>
        <button class="ctrl-btn" id="btnBurst" title="Color burst">&#9673;</button>
        <button class="ctrl-btn" id="btnPalette" title="Next palette">&#9680;</button>
    </div>

    <div class="title-overlay">
        <h1>Fluid Verse</h1>
    </div>

    <script>
    'use strict';

    /* ═══════════════════════════════════════════════════════
       CONFIGURATION
       ═══════════════════════════════════════════════════════ */

    var config = {
        SIM_RESOLUTION: 256,
        DYE_RESOLUTION: 1024,
        DENSITY_DISSIPATION: 1.2,
        VELOCITY_DISSIPATION: 0.6,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        SPLAT_RADIUS: 0.25,
        SPLAT_FORCE: 6000,
        BLOOM: true,
        BLOOM_ITERATIONS: 8,
        BLOOM_RESOLUTION: 256,
        BLOOM_INTENSITY: 0.7,
        BLOOM_THRESHOLD: 0.6,
        BLOOM_SOFT_KNEE: 0.7,
        AUTO_SPLAT_INTERVAL: 600,
        PALETTE: 0
    };

    var PALETTES = [
        null,
        [[1,0.2,0.5],[0,0.8,1],[1,0.9,0],[0.4,1,0.4],[1,0.4,0]],
        [[0,0.3,0.8],[0,0.6,0.7],[0,0.8,0.6],[0.1,0.4,0.9],[0.3,0,0.8]],
        [[1,0.3,0.1],[1,0.5,0],[0.9,0.1,0.3],[1,0.7,0],[0.6,0,0.4]],
        [[1,0,0.8],[0,1,0.8],[0.8,1,0],[0,0.5,1],[1,0,0.3]]
    ];

    var PALETTE_NAMES = ['Rainbow', 'Murakami', 'Ocean', 'Sunset', 'Neon'];

    /* ═══════════════════════════════════════════════════════
       WEBGL CONTEXT
       ═══════════════════════════════════════════════════════ */

    var canvas = document.getElementById('fluid');
    var gl = canvas.getContext('webgl2', {
        alpha: true, depth: false, stencil: false,
        antialias: false, preserveDrawingBuffer: false
    });

    if (!gl) {
        document.body.innerHTML = '<p style="color:#fff;text-align:center;margin-top:45vh;font-family:Inter,sans-serif;font-size:16px">WebGL 2 is required for this experiment.</p>';
        throw new Error('WebGL2 not available');
    }

    gl.getExtension('EXT_color_buffer_float');
    var supportLinear = gl.getExtension('OES_texture_float_linear');

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    var texType = gl.HALF_FLOAT;
    var formatRGBA = { internalFormat: gl.RGBA16F, format: gl.RGBA };
    var formatRG   = { internalFormat: gl.RG16F,   format: gl.RG };
    var formatR    = { internalFormat: gl.R16F,     format: gl.RED };

    /* Test render target support and fallback */
    if (!supportRT(formatR.internalFormat, formatR.format)) {
        formatR = formatRG;
    }
    if (!supportRT(formatRG.internalFormat, formatRG.format)) {
        formatRG = formatRGBA;
    }

    function supportRT(intFmt, fmt) {
        var t = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, t);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, intFmt, 4, 4, 0, fmt, texType, null);
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t, 0);
        var ok = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.deleteFramebuffer(fb);
        gl.deleteTexture(t);
        return ok;
    }

    /* ═══════════════════════════════════════════════════════
       SHADER HELPERS
       ═══════════════════════════════════════════════════════ */

    function compileShader(type, source) {
        var s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
            throw new Error(gl.getShaderInfoLog(s));
        return s;
    }

    function createProgram(vs, fs) {
        var p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS))
            throw new Error(gl.getProgramInfoLog(p));
        return p;
    }

    function getUniforms(program) {
        var u = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveUniform(program, i);
            u[info.name] = gl.getUniformLocation(program, info.name);
        }
        return u;
    }

    function Program(vertSrc, fragSrc) {
        this.vs = compileShader(gl.VERTEX_SHADER, vertSrc);
        this.fs = compileShader(gl.FRAGMENT_SHADER, fragSrc);
        this.prog = createProgram(this.vs, this.fs);
        this.uniforms = getUniforms(this.prog);
    }

    Program.prototype.bind = function() {
        gl.useProgram(this.prog);
    };

    /* ═══════════════════════════════════════════════════════
       GEOMETRY (fullscreen triangle)
       ═══════════════════════════════════════════════════════ */

    var quadVAO = gl.createVertexArray();
    gl.bindVertexArray(quadVAO);
    var quadVBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, -1,1, 1,1, 1,-1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    var quadIBO = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);
    gl.bindVertexArray(null);

    function blit(fbo) {
        if (fbo) {
            gl.viewport(0, 0, fbo.width, fbo.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.fbo);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        gl.bindVertexArray(quadVAO);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }

    /* ═══════════════════════════════════════════════════════
       FRAMEBUFFER OBJECTS
       ═══════════════════════════════════════════════════════ */

    function createFBO(w, h, intFmt, fmt, type, filter) {
        gl.activeTexture(gl.TEXTURE0);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, intFmt, w, h, 0, fmt, type, null);

        var fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return {
            texture: texture, fbo: fbo, width: w, height: h,
            attach: function(unit) {
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                return unit;
            }
        };
    }

    function createDoubleFBO(w, h, intFmt, fmt, type, filter) {
        var fbo1 = createFBO(w, h, intFmt, fmt, type, filter);
        var fbo2 = createFBO(w, h, intFmt, fmt, type, filter);
        return {
            width: w, height: h,
            texelSizeX: 1.0 / w,
            texelSizeY: 1.0 / h,
            read: fbo1,
            write: fbo2,
            swap: function() {
                var tmp = this.read;
                this.read = this.write;
                this.write = tmp;
            }
        };
    }

    function resizeFBO(target, w, h, intFmt, fmt, type, filter) {
        var newFBO = createFBO(w, h, intFmt, fmt, type, filter);
        copyProg.bind();
        gl.uniform1i(copyProg.uniforms.uTexture, target.attach(0));
        blit(newFBO);
        return newFBO;
    }

    function resizeDoubleFBO(target, w, h, intFmt, fmt, type, filter) {
        if (target.width === w && target.height === h) return target;
        target.read = resizeFBO(target.read, w, h, intFmt, fmt, type, filter);
        target.write = createFBO(w, h, intFmt, fmt, type, filter);
        target.width = w;
        target.height = h;
        target.texelSizeX = 1.0 / w;
        target.texelSizeY = 1.0 / h;
        return target;
    }

    /* ═══════════════════════════════════════════════════════
       SHADER SOURCES
       ═══════════════════════════════════════════════════════ */

    var baseVert = '#version 300 es\n\
precision highp float;\n\
layout(location=0) in vec2 aPosition;\n\
out vec2 vUv;\n\
out vec2 vL, vR, vT, vB;\n\
uniform vec2 texelSize;\n\
void main(){\n\
    vUv = aPosition * 0.5 + 0.5;\n\
    vL = vUv - vec2(texelSize.x, 0.0);\n\
    vR = vUv + vec2(texelSize.x, 0.0);\n\
    vT = vUv + vec2(0.0, texelSize.y);\n\
    vB = vUv - vec2(0.0, texelSize.y);\n\
    gl_Position = vec4(aPosition, 0.0, 1.0);\n\
}';

    var copyFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
out vec4 fragColor;\n\
void main(){ fragColor = texture(uTexture, vUv); }';

    var clearFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform float value;\n\
out vec4 fragColor;\n\
void main(){\n\
    fragColor = value * texture(uTexture, vUv);\n\
}';

    var splatFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uTarget;\n\
uniform float aspectRatio;\n\
uniform vec3 color;\n\
uniform vec2 point;\n\
uniform float radius;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 p = vUv - point;\n\
    p.x *= aspectRatio;\n\
    vec3 splat = exp(-dot(p,p) / radius) * color;\n\
    vec3 base = texture(uTarget, vUv).xyz;\n\
    fragColor = vec4(base + splat, 1.0);\n\
}';

    var advectionFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uSource;\n\
uniform vec2 texelSize;\n\
uniform float dt;\n\
uniform float dissipation;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 coord = vUv - dt * texture(uVelocity, vUv).xy * texelSize;\n\
    vec3 result = dissipation * texture(uSource, coord).xyz;\n\
    float decay = dissipation < 1.0 ? max(0.0, 1.0 - 0.0002) : 1.0;\n\
    fragColor = vec4(result * decay, 1.0);\n\
}';

    var divergenceFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uVelocity, vL).x;\n\
    float R = texture(uVelocity, vR).x;\n\
    float T = texture(uVelocity, vT).y;\n\
    float B = texture(uVelocity, vB).y;\n\
    float div = 0.5 * (R - L + T - B);\n\
    fragColor = vec4(div, 0.0, 0.0, 1.0);\n\
}';

    var curlFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uVelocity, vL).y;\n\
    float R = texture(uVelocity, vR).y;\n\
    float T = texture(uVelocity, vT).x;\n\
    float B = texture(uVelocity, vB).x;\n\
    float vorticity = R - L - T + B;\n\
    fragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n\
}';

    var vorticityFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uCurl;\n\
uniform float curl;\n\
uniform float dt;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uCurl, vL).x;\n\
    float R = texture(uCurl, vR).x;\n\
    float T = texture(uCurl, vT).x;\n\
    float B = texture(uCurl, vB).x;\n\
    float C = texture(uCurl, vUv).x;\n\
    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n\
    force /= length(force) + 0.0001;\n\
    force *= curl * C;\n\
    force.y *= -1.0;\n\
    vec2 velocity = texture(uVelocity, vUv).xy;\n\
    velocity += force * dt;\n\
    velocity = min(max(velocity, -1000.0), 1000.0);\n\
    fragColor = vec4(velocity, 0.0, 1.0);\n\
}';

    var pressureFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uPressure;\n\
uniform sampler2D uDivergence;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uPressure, vL).x;\n\
    float R = texture(uPressure, vR).x;\n\
    float T = texture(uPressure, vT).x;\n\
    float B = texture(uPressure, vB).x;\n\
    float divergence = texture(uDivergence, vUv).x;\n\
    float pressure = (L + R + B + T - divergence) * 0.25;\n\
    fragColor = vec4(pressure, 0.0, 0.0, 1.0);\n\
}';

    var gradSubFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uPressure;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uPressure, vL).x;\n\
    float R = texture(uPressure, vR).x;\n\
    float T = texture(uPressure, vT).x;\n\
    float B = texture(uPressure, vB).x;\n\
    vec2 velocity = texture(uVelocity, vUv).xy;\n\
    velocity.xy -= vec2(R - L, T - B);\n\
    fragColor = vec4(velocity, 0.0, 1.0);\n\
}';

    var displayFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec3 c = texture(uTexture, vUv).rgb;\n\
    /* Subtle shading: darken edges slightly */\n\
    float vignette = 1.0 - 0.3 * length(vUv - 0.5);\n\
    c *= vignette;\n\
    fragColor = vec4(c, 1.0);\n\
}';

    var displayBloomFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform sampler2D uBloom;\n\
uniform float bloomIntensity;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec3 c = texture(uTexture, vUv).rgb;\n\
    vec3 bloom = texture(uBloom, vUv).rgb;\n\
    c += bloom * bloomIntensity;\n\
    /* Filmic tonemap (ACES approximation) */\n\
    float a = 2.51, b = 0.03, cc = 2.43, d = 0.59, e = 0.14;\n\
    c = clamp((c*(a*c+b))/(c*(cc*c+d)+e), 0.0, 1.0);\n\
    /* Subtle vignette */\n\
    float vig = 1.0 - 0.25 * length(vUv - 0.5);\n\
    c *= vig;\n\
    fragColor = vec4(c, 1.0);\n\
}';

    var bloomPrefilterFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform vec3 curve;\n\
uniform float threshold;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec3 c = texture(uTexture, vUv).rgb;\n\
    float br = max(c.r, max(c.g, c.b));\n\
    float rq = clamp(br - curve.x, 0.0, curve.y);\n\
    rq = curve.z * rq * rq;\n\
    c *= max(rq, br - threshold) / max(br, 0.0001);\n\
    fragColor = vec4(c, 1.0);\n\
}';

    var bloomBlurFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR;\n\
uniform sampler2D uTexture;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec4 sum = vec4(0.0);\n\
    sum += texture(uTexture, vL) * 0.25;\n\
    sum += texture(uTexture, vUv) * 0.5;\n\
    sum += texture(uTexture, vR) * 0.25;\n\
    fragColor = sum;\n\
}';

    var bloomFinalFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform float intensity;\n\
out vec4 fragColor;\n\
void main(){\n\
    fragColor = intensity * texture(uTexture, vUv);\n\
}';

    /* Bloom uses separate vertex shader for directional blur */
    var bloomBlurVert = '#version 300 es\n\
precision highp float;\n\
layout(location=0) in vec2 aPosition;\n\
out vec2 vUv;\n\
out vec2 vL, vR;\n\
uniform vec2 texelSize;\n\
void main(){\n\
    vUv = aPosition * 0.5 + 0.5;\n\
    float offset = 1.33333;\n\
    vL = vUv - texelSize * offset;\n\
    vR = vUv + texelSize * offset;\n\
    gl_Position = vec4(aPosition, 0.0, 1.0);\n\
}';

    /* ═══════════════════════════════════════════════════════
       COMPILE PROGRAMS
       ═══════════════════════════════════════════════════════ */

    var copyProg           = new Program(baseVert, copyFrag);
    var clearProg          = new Program(baseVert, clearFrag);
    var splatProg          = new Program(baseVert, splatFrag);
    var advectionProg      = new Program(baseVert, advectionFrag);
    var divergenceProg     = new Program(baseVert, divergenceFrag);
    var curlProg           = new Program(baseVert, curlFrag);
    var vorticityProg      = new Program(baseVert, vorticityFrag);
    var pressureProg       = new Program(baseVert, pressureFrag);
    var gradSubProg        = new Program(baseVert, gradSubFrag);
    var displayProg        = new Program(baseVert, displayFrag);
    var displayBloomProg   = new Program(baseVert, displayBloomFrag);
    var bloomPrefilterProg = new Program(baseVert, bloomPrefilterFrag);
    var bloomBlurProg      = new Program(bloomBlurVert, bloomBlurFrag);
    var bloomFinalProg     = new Program(baseVert, bloomFinalFrag);

    /* ═══════════════════════════════════════════════════════
       INIT FRAMEBUFFERS
       ═══════════════════════════════════════════════════════ */

    var dye, velocity, divergence, curl, pressure;
    var bloomFBOs = [];

    function getResolution(resolution) {
        var aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
        if (aspect < 1) aspect = 1.0 / aspect;
        var min = Math.round(resolution);
        var max = Math.round(resolution * aspect);
        if (gl.drawingBufferWidth > gl.drawingBufferHeight)
            return { width: max, height: min };
        else
            return { width: min, height: max };
    }

    function initFramebuffers() {
        var simRes = getResolution(config.SIM_RESOLUTION);
        var dyeRes = getResolution(config.DYE_RESOLUTION);

        var simFilter = supportLinear ? gl.LINEAR : gl.NEAREST;
        var dyeFilter = supportLinear ? gl.LINEAR : gl.NEAREST;

        if (!dye) {
            dye = createDoubleFBO(dyeRes.width, dyeRes.height,
                formatRGBA.internalFormat, formatRGBA.format, texType, dyeFilter);
        } else {
            dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height,
                formatRGBA.internalFormat, formatRGBA.format, texType, dyeFilter);
        }

        if (!velocity) {
            velocity = createDoubleFBO(simRes.width, simRes.height,
                formatRG.internalFormat, formatRG.format, texType, simFilter);
        } else {
            velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height,
                formatRG.internalFormat, formatRG.format, texType, simFilter);
        }

        divergence = createFBO(simRes.width, simRes.height,
            formatR.internalFormat, formatR.format, texType, gl.NEAREST);
        curl = createFBO(simRes.width, simRes.height,
            formatR.internalFormat, formatR.format, texType, gl.NEAREST);
        pressure = createDoubleFBO(simRes.width, simRes.height,
            formatR.internalFormat, formatR.format, texType, gl.NEAREST);

        initBloomFBOs();
    }

    function initBloomFBOs() {
        var res = getResolution(config.BLOOM_RESOLUTION);
        var filter = supportLinear ? gl.LINEAR : gl.NEAREST;
        bloomFBOs.length = 0;
        for (var i = 0; i < config.BLOOM_ITERATIONS; i++) {
            var w = res.width >> (i + 1);
            var h = res.height >> (i + 1);
            if (w < 2 || h < 2) break;
            bloomFBOs.push(createFBO(w, h,
                formatRGBA.internalFormat, formatRGBA.format, texType, filter));
        }
    }

    initFramebuffers();

    /* ═══════════════════════════════════════════════════════
       RESIZE HANDLING
       ═══════════════════════════════════════════════════════ */

    function resizeCanvas() {
        var w = window.innerWidth;
        var h = window.innerHeight;
        if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            initFramebuffers();
        }
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas, { passive: true });

    /* ═══════════════════════════════════════════════════════
       SIMULATION
       ═══════════════════════════════════════════════════════ */

    function step(dt) {
        gl.disable(gl.BLEND);

        /* Curl */
        curlProg.bind();
        gl.uniform2f(curlProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(curlProg.uniforms.uVelocity, velocity.read.attach(0));
        blit(curl);

        /* Vorticity confinement */
        vorticityProg.bind();
        gl.uniform2f(vorticityProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(vorticityProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(vorticityProg.uniforms.uCurl, curl.attach(1));
        gl.uniform1f(vorticityProg.uniforms.curl, config.CURL);
        gl.uniform1f(vorticityProg.uniforms.dt, dt);
        blit(velocity.write);
        velocity.swap();

        /* Divergence */
        divergenceProg.bind();
        gl.uniform2f(divergenceProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(divergenceProg.uniforms.uVelocity, velocity.read.attach(0));
        blit(divergence);

        /* Clear pressure */
        clearProg.bind();
        gl.uniform1i(clearProg.uniforms.uTexture, pressure.read.attach(0));
        gl.uniform1f(clearProg.uniforms.value, config.PRESSURE);
        blit(pressure.write);
        pressure.swap();

        /* Pressure solve (Jacobi iterations) */
        pressureProg.bind();
        gl.uniform2f(pressureProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(pressureProg.uniforms.uDivergence, divergence.attach(0));
        for (var i = 0; i < config.PRESSURE_ITERATIONS; i++) {
            gl.uniform1i(pressureProg.uniforms.uPressure, pressure.read.attach(1));
            blit(pressure.write);
            pressure.swap();
        }

        /* Gradient subtraction */
        gradSubProg.bind();
        gl.uniform2f(gradSubProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(gradSubProg.uniforms.uPressure, pressure.read.attach(0));
        gl.uniform1i(gradSubProg.uniforms.uVelocity, velocity.read.attach(1));
        blit(velocity.write);
        velocity.swap();

        /* Advect velocity */
        advectionProg.bind();
        gl.uniform2f(advectionProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(advectionProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(advectionProg.uniforms.uSource, velocity.read.attach(0));
        gl.uniform1f(advectionProg.uniforms.dt, dt);
        gl.uniform1f(advectionProg.uniforms.dissipation, config.VELOCITY_DISSIPATION);
        blit(velocity.write);
        velocity.swap();

        /* Advect dye */
        gl.uniform2f(advectionProg.uniforms.texelSize, dye.texelSizeX, dye.texelSizeY);
        gl.uniform1i(advectionProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(advectionProg.uniforms.uSource, dye.read.attach(1));
        gl.uniform1f(advectionProg.uniforms.dissipation, config.DENSITY_DISSIPATION);
        blit(dye.write);
        dye.swap();
    }

    /* ═══════════════════════════════════════════════════════
       BLOOM
       ═══════════════════════════════════════════════════════ */

    function applyBloom(source) {
        if (bloomFBOs.length < 2) return;

        var last = bloomFBOs[0];

        /* Prefilter: threshold bright areas */
        var knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;
        var curve0 = config.BLOOM_THRESHOLD - knee;
        var curve1 = knee * 2.0;
        var curve2 = 0.25 / knee;

        bloomPrefilterProg.bind();
        gl.uniform1i(bloomPrefilterProg.uniforms.uTexture, source.attach(0));
        gl.uniform3f(bloomPrefilterProg.uniforms.curve, curve0, curve1, curve2);
        gl.uniform1f(bloomPrefilterProg.uniforms.threshold, config.BLOOM_THRESHOLD);
        blit(last);

        /* Progressive downscale + blur */
        bloomBlurProg.bind();
        for (var i = 1; i < bloomFBOs.length; i++) {
            var dest = bloomFBOs[i];
            /* Horizontal pass */
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 1.0 / last.width, 0.0);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, last.attach(0));
            blit(dest);
            /* Vertical pass (use same dest, ping-pong would be better but this is fast enough) */
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 0.0, 1.0 / dest.height);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, dest.attach(0));
            blit(dest);
            last = dest;
        }

        /* Progressive upscale + accumulate */
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);

        for (var i = bloomFBOs.length - 2; i >= 0; i--) {
            var dest = bloomFBOs[i];
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 1.0 / last.width, 0.0);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, last.attach(0));
            blit(dest);
            last = dest;
        }

        gl.disable(gl.BLEND);
    }

    /* ═══════════════════════════════════════════════════════
       RENDER
       ═══════════════════════════════════════════════════════ */

    function render() {
        if (config.BLOOM) {
            applyBloom(dye.read);
            displayBloomProg.bind();
            gl.uniform1i(displayBloomProg.uniforms.uTexture, dye.read.attach(0));
            gl.uniform1i(displayBloomProg.uniforms.uBloom, bloomFBOs[0].attach(1));
            gl.uniform1f(displayBloomProg.uniforms.bloomIntensity, config.BLOOM_INTENSITY);
        } else {
            displayProg.bind();
            gl.uniform1i(displayProg.uniforms.uTexture, dye.read.attach(0));
        }
        blit(null);
    }

    /* ═══════════════════════════════════════════════════════
       SPLATS
       ═══════════════════════════════════════════════════════ */

    function splat(x, y, dx, dy, color) {
        splatProg.bind();
        gl.uniform1i(splatProg.uniforms.uTarget, velocity.read.attach(0));
        gl.uniform1f(splatProg.uniforms.aspectRatio, canvas.width / canvas.height);
        gl.uniform2f(splatProg.uniforms.point, x, y);
        gl.uniform3f(splatProg.uniforms.color, dx, dy, 0.0);
        gl.uniform1f(splatProg.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
        blit(velocity.write);
        velocity.swap();

        gl.uniform1i(splatProg.uniforms.uTarget, dye.read.attach(0));
        gl.uniform3f(splatProg.uniforms.color, color.r, color.g, color.b);
        blit(dye.write);
        dye.swap();
    }

    function correctRadius(radius) {
        var aspect = canvas.width / canvas.height;
        if (aspect > 1) radius *= aspect;
        return radius;
    }

    function generateColor() {
        var palette = PALETTES[config.PALETTE];
        if (palette) {
            var c = palette[Math.floor(Math.random() * palette.length)];
            return { r: c[0] * 0.15, g: c[1] * 0.15, b: c[2] * 0.15 };
        }
        var c = HSVtoRGB(Math.random(), 1.0, 1.0);
        c.r *= 0.15;
        c.g *= 0.15;
        c.b *= 0.15;
        return c;
    }

    function HSVtoRGB(h, s, v) {
        var i = Math.floor(h * 6);
        var f = h * 6 - i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var r, g, b;
        switch (i % 6) {
            case 0: r=v; g=t; b=p; break;
            case 1: r=q; g=v; b=p; break;
            case 2: r=p; g=v; b=t; break;
            case 3: r=p; g=q; b=v; break;
            case 4: r=t; g=p; b=v; break;
            case 5: r=v; g=p; b=q; break;
        }
        return { r: r, g: g, b: b };
    }

    /* ═══════════════════════════════════════════════════════
       INPUT HANDLING
       ═══════════════════════════════════════════════════════ */

    var pointers = [];
    var hintEl = document.getElementById('hint');
    var hintDismissed = false;

    function Pointer() {
        this.id = -1;
        this.texX = 0; this.texY = 0;
        this.prevTexX = 0; this.prevTexY = 0;
        this.deltaX = 0; this.deltaY = 0;
        this.down = false;
        this.moved = false;
        this.color = generateColor();
    }

    pointers.push(new Pointer());

    function getPointerById(id) {
        for (var i = 0; i < pointers.length; i++) {
            if (pointers[i].id === id) return pointers[i];
        }
        return null;
    }

    function updatePointerDown(ptr, id, posX, posY) {
        ptr.id = id;
        ptr.down = true;
        ptr.moved = false;
        ptr.texX = posX / canvas.width;
        ptr.texY = 1.0 - posY / canvas.height;
        ptr.prevTexX = ptr.texX;
        ptr.prevTexY = ptr.texY;
        ptr.color = generateColor();
    }

    function updatePointerMove(ptr, posX, posY) {
        ptr.prevTexX = ptr.texX;
        ptr.prevTexY = ptr.texY;
        ptr.texX = posX / canvas.width;
        ptr.texY = 1.0 - posY / canvas.height;
        ptr.deltaX = correctDelta(ptr.texX - ptr.prevTexX);
        ptr.deltaY = correctDelta(ptr.texY - ptr.prevTexY);
        ptr.moved = Math.abs(ptr.deltaX) > 0 || Math.abs(ptr.deltaY) > 0;

        if (!hintDismissed && ptr.moved) {
            hintDismissed = true;
            hintEl.classList.add('hidden');
        }
    }

    function correctDelta(delta) {
        return delta;
    }

    /* Mouse events */
    canvas.addEventListener('mousedown', function(e) {
        updatePointerDown(pointers[0], -1, e.offsetX, e.offsetY);
    });
    canvas.addEventListener('mousemove', function(e) {
        pointers[0].down = (e.buttons & 1) !== 0;
        updatePointerMove(pointers[0], e.offsetX, e.offsetY);
    });
    canvas.addEventListener('mouseup', function() {
        pointers[0].down = false;
    });

    /* Touch events */
    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        for (var i = 0; i < e.changedTouches.length; i++) {
            var t = e.changedTouches[i];
            var ptr = getPointerById(t.identifier);
            if (!ptr) {
                ptr = new Pointer();
                pointers.push(ptr);
            }
            updatePointerDown(ptr, t.identifier, t.clientX, t.clientY);
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        for (var i = 0; i < e.changedTouches.length; i++) {
            var t = e.changedTouches[i];
            var ptr = getPointerById(t.identifier);
            if (ptr) updatePointerMove(ptr, t.clientX, t.clientY);
        }
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
        for (var i = 0; i < e.changedTouches.length; i++) {
            var ptr = getPointerById(e.changedTouches[i].identifier);
            if (ptr) ptr.down = false;
        }
    });

    /* ═══════════════════════════════════════════════════════
       AUTO-SPLAT (ATTRACT MODE)
       ═══════════════════════════════════════════════════════ */

    var autoSplatTimer = 0;
    var attractTime = 0;

    function autoSplat(dt) {
        autoSplatTimer += dt;
        attractTime += dt;

        if (autoSplatTimer < config.AUTO_SPLAT_INTERVAL / 1000) return;
        autoSplatTimer = 0;

        /* Lissajous curve positions for organic movement */
        var t = attractTime;
        var x = 0.5 + 0.35 * Math.sin(t * 0.7 + 1.2);
        var y = 0.5 + 0.35 * Math.cos(t * 0.5 + 0.8);
        var dx = 500 * Math.cos(t * 1.3);
        var dy = 500 * Math.sin(t * 0.9);
        var color = generateColor();
        splat(x, y, dx, dy, color);

        /* Occasional burst: multiple splats in a ring */
        if (Math.random() < 0.15) {
            var cx = 0.3 + Math.random() * 0.4;
            var cy = 0.3 + Math.random() * 0.4;
            var count = 5 + Math.floor(Math.random() * 7);
            for (var i = 0; i < count; i++) {
                var angle = (i / count) * Math.PI * 2;
                var r = 0.03 + Math.random() * 0.06;
                var bx = cx + Math.cos(angle) * r;
                var by = cy + Math.sin(angle) * r;
                var bdx = Math.cos(angle) * 1200;
                var bdy = Math.sin(angle) * 1200;
                splat(bx, by, bdx, bdy, generateColor());
            }
        }
    }

    /* ═══════════════════════════════════════════════════════
       COLOR BURST (manual trigger)
       ═══════════════════════════════════════════════════════ */

    function triggerBurst() {
        var cx = 0.3 + Math.random() * 0.4;
        var cy = 0.3 + Math.random() * 0.4;
        var count = 8 + Math.floor(Math.random() * 8);
        for (var i = 0; i < count; i++) {
            var angle = (i / count) * Math.PI * 2 + Math.random() * 0.3;
            var r = 0.04 + Math.random() * 0.08;
            var bx = cx + Math.cos(angle) * r;
            var by = cy + Math.sin(angle) * r;
            var force = 800 + Math.random() * 1600;
            var bdx = Math.cos(angle) * force;
            var bdy = Math.sin(angle) * force;
            splat(bx, by, bdx, bdy, generateColor());
        }
    }

    /* ═══════════════════════════════════════════════════════
       MAIN LOOP
       ═══════════════════════════════════════════════════════ */

    var lastTime = performance.now();

    function frame(now) {
        var dt = Math.min((now - lastTime) / 1000, 0.016667);
        lastTime = now;

        resizeCanvas();

        /* Process pointer input */
        for (var i = 0; i < pointers.length; i++) {
            var p = pointers[i];
            if (p.moved) {
                p.moved = false;
                var force = config.SPLAT_FORCE;
                splat(p.texX, p.texY, p.deltaX * force, p.deltaY * force, p.color);
            }
            if (p.down) {
                p.color = generateColor();
            }
        }

        /* Auto-splat attract mode */
        autoSplat(dt);

        /* Simulation step */
        step(dt);

        /* Render */
        render();

        requestAnimationFrame(frame);
    }

    /* Initial splash of color */
    (function initialSplash() {
        var count = 5 + Math.floor(Math.random() * 5);
        for (var i = 0; i < count; i++) {
            var x = 0.15 + Math.random() * 0.7;
            var y = 0.15 + Math.random() * 0.7;
            var angle = Math.random() * Math.PI * 2;
            var force = 400 + Math.random() * 800;
            splat(x, y, Math.cos(angle) * force, Math.sin(angle) * force, generateColor());
        }
    })();

    requestAnimationFrame(frame);

    /* ═══════════════════════════════════════════════════════
       UI CONTROLS
       ═══════════════════════════════════════════════════════ */

    document.getElementById('btnReset').addEventListener('click', function() {
        /* Clear all framebuffers */
        gl.bindFramebuffer(gl.FRAMEBUFFER, dye.read.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, dye.write.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.read.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.write.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.read.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    });

    var btnBloom = document.getElementById('btnBloom');
    btnBloom.addEventListener('click', function() {
        config.BLOOM = !config.BLOOM;
        btnBloom.classList.toggle('active', config.BLOOM);
    });

    document.getElementById('btnBurst').addEventListener('click', function() {
        triggerBurst();
    });

    var btnPalette = document.getElementById('btnPalette');
    btnPalette.addEventListener('click', function() {
        config.PALETTE = (config.PALETTE + 1) % PALETTES.length;
        btnPalette.title = PALETTE_NAMES[config.PALETTE] || 'Rainbow';
    });

    /* Keyboard shortcuts */
    document.addEventListener('keydown', function(e) {
        if (e.key === ' ' || e.code === 'Space') {
            e.preventDefault();
            triggerBurst();
        }
        if (e.key === 'r' || e.key === 'R') {
            document.getElementById('btnReset').click();
        }
        if (e.key === 'b' || e.key === 'B') {
            btnBloom.click();
        }
        if (e.key === 'p' || e.key === 'P') {
            btnPalette.click();
        }
    });

    /* prefers-reduced-motion: disable auto-splat */
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        config.AUTO_SPLAT_INTERVAL = 99999999;
    }
    </script>
</body>
</html>
