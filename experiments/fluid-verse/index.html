<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluid Verse — MADvids</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            user-select: none;
        }

        canvas { width: 100vw; height: 100vh; display: block; }

        video#bgVideo {
            position: fixed;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* ─── Glass Nav ─── */
        .glass-nav {
            position: fixed;
            top: max(16px, env(safe-area-inset-top, 16px));
            left: max(16px, env(safe-area-inset-left, 16px));
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .glass-nav a {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .glass-nav a:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff;
        }

        /* ─── Controls ─── */
        .controls-panel {
            position: fixed;
            bottom: max(16px, env(safe-area-inset-bottom, 16px));
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 5px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
        }

        .mode-group {
            display: flex;
            gap: 2px;
            padding: 2px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
        }

        .mode-btn {
            padding: 8px 14px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.45);
            font-size: 12px;
            font-weight: 500;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.25s ease;
            letter-spacing: 0.01em;
            white-space: nowrap;
        }

        .mode-btn:hover { color: rgba(255, 255, 255, 0.7); }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.14);
            color: #fff;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 4px;
        }

        .ctrl-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.45);
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.25s ease;
            white-space: nowrap;
        }

        .ctrl-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        .ctrl-btn.active {
            background: rgba(255, 255, 255, 0.14);
            border-color: rgba(255, 255, 255, 0.15);
            color: #fff;
        }

        /* ─── Hint ─── */
        .hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: clamp(13px, 2.2vw, 17px);
            font-weight: 300;
            letter-spacing: 3px;
            pointer-events: none;
            transition: opacity 2s ease;
            text-align: center;
            text-transform: uppercase;
        }

        .hint.hidden { opacity: 0; }

        .title-overlay {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom, 20px));
            right: max(20px, env(safe-area-inset-right, 20px));
            z-index: 50;
            pointer-events: none;
        }

        .title-overlay h1 {
            font-size: 11px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.15);
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .glass-nav { top: 12px; left: 12px; }
            .controls-panel { bottom: 12px; gap: 3px; padding: 4px; }
            .mode-btn { padding: 7px 10px; font-size: 11px; }
            .ctrl-btn { padding: 7px 10px; font-size: 10px; }
            .divider { margin: 0 2px; }
        }

        @media (prefers-reduced-motion: reduce) {
            .hint { transition: none; }
        }
    </style>
</head>
<body>
    <canvas id="fluid"></canvas>

    <video id="bgVideo" muted autoplay loop playsinline preload="auto" crossorigin="anonymous">
        <source src="https://storage.googleapis.com/myproject-public-assets/ddn/videos/test/hyperpod-kjhxsa.mp4" type="video/mp4">
    </video>

    <nav class="glass-nav">
        <a href="/MADvids/">&#8592; Back</a>
    </nav>

    <div class="hint" id="hint">Drag across the video</div>

    <div class="controls-panel">
        <div class="mode-group">
            <button class="mode-btn active" data-mode="liquid">Liquid</button>
            <button class="mode-btn" data-mode="prism">Prism</button>
            <button class="mode-btn" data-mode="ink">Ink</button>
        </div>
        <div class="divider"></div>
        <button class="ctrl-btn active" id="btnBloom">Bloom</button>
        <button class="ctrl-btn" id="btnBurst">Burst</button>
        <button class="ctrl-btn" id="btnReset">Reset</button>
    </div>

    <div class="title-overlay">
        <h1>Fluid Verse</h1>
    </div>

    <script>
    'use strict';

    /* ═══════════════════════════════════════════════════════
       CONFIGURATION
       ═══════════════════════════════════════════════════════ */

    var config = {
        SIM_RESOLUTION: 256,
        DYE_RESOLUTION: 1024,
        DENSITY_DISSIPATION: 1.2,
        VELOCITY_DISSIPATION: 0.6,
        PRESSURE: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        SPLAT_RADIUS: 0.25,
        SPLAT_FORCE: 6000,
        BLOOM: true,
        BLOOM_ITERATIONS: 8,
        BLOOM_RESOLUTION: 256,
        BLOOM_INTENSITY: 0.7,
        BLOOM_THRESHOLD: 0.6,
        BLOOM_SOFT_KNEE: 0.7,
        AUTO_SPLAT_INTERVAL: 800,
        PALETTE: 0,
        MODE: 'liquid',
        DISTORTION: 0.00025
    };

    var PALETTES = [
        null,
        [[1,0.2,0.5],[0,0.8,1],[1,0.9,0],[0.4,1,0.4],[1,0.4,0]],
        [[0,0.3,0.8],[0,0.6,0.7],[0,0.8,0.6],[0.1,0.4,0.9],[0.3,0,0.8]],
        [[1,0.3,0.1],[1,0.5,0],[0.9,0.1,0.3],[1,0.7,0],[0.6,0,0.4]],
        [[1,0,0.8],[0,1,0.8],[0.8,1,0],[0,0.5,1],[1,0,0.3]]
    ];

    /* ═══════════════════════════════════════════════════════
       WEBGL CONTEXT
       ═══════════════════════════════════════════════════════ */

    var canvas = document.getElementById('fluid');
    var gl = canvas.getContext('webgl2', {
        alpha: true, depth: false, stencil: false,
        antialias: false, preserveDrawingBuffer: false
    });

    if (!gl) {
        document.body.innerHTML = '<p style="color:#fff;text-align:center;margin-top:45vh;font-family:Inter,sans-serif">WebGL 2 is required.</p>';
        throw new Error('WebGL2 not available');
    }

    gl.getExtension('EXT_color_buffer_float');
    var supportLinear = gl.getExtension('OES_texture_float_linear');
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    var texType = gl.HALF_FLOAT;
    var formatRGBA = { internalFormat: gl.RGBA16F, format: gl.RGBA };
    var formatRG   = { internalFormat: gl.RG16F,   format: gl.RG };
    var formatR    = { internalFormat: gl.R16F,     format: gl.RED };

    if (!supportRT(formatR.internalFormat, formatR.format)) formatR = formatRG;
    if (!supportRT(formatRG.internalFormat, formatRG.format)) formatRG = formatRGBA;

    function supportRT(intFmt, fmt) {
        var t = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, t);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, intFmt, 4, 4, 0, fmt, texType, null);
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t, 0);
        var ok = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.deleteFramebuffer(fb);
        gl.deleteTexture(t);
        return ok;
    }

    /* ═══════════════════════════════════════════════════════
       VIDEO TEXTURE
       ═══════════════════════════════════════════════════════ */

    var video = document.getElementById('bgVideo');
    var videoReady = false;
    var videoTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, videoTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 255]));

    function updateVideoTexture() {
        if (!videoReady || video.readyState < video.HAVE_CURRENT_DATA) return;
        gl.bindTexture(gl.TEXTURE_2D, videoTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    }

    function attachVideoTexture(unit) {
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, videoTexture);
        return unit;
    }

    video.addEventListener('playing', function() { videoReady = true; });
    video.play().catch(function() {});

    /* ═══════════════════════════════════════════════════════
       SHADER HELPERS
       ═══════════════════════════════════════════════════════ */

    function compileShader(type, source) {
        var s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
            throw new Error(gl.getShaderInfoLog(s));
        return s;
    }

    function createProgram(vs, fs) {
        var p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS))
            throw new Error(gl.getProgramInfoLog(p));
        return p;
    }

    function getUniforms(program) {
        var u = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveUniform(program, i);
            u[info.name] = gl.getUniformLocation(program, info.name);
        }
        return u;
    }

    function ShaderProgram(vertSrc, fragSrc) {
        this.vs = compileShader(gl.VERTEX_SHADER, vertSrc);
        this.fs = compileShader(gl.FRAGMENT_SHADER, fragSrc);
        this.prog = createProgram(this.vs, this.fs);
        this.uniforms = getUniforms(this.prog);
    }

    ShaderProgram.prototype.bind = function() { gl.useProgram(this.prog); };

    /* ═══════════════════════════════════════════════════════
       GEOMETRY
       ═══════════════════════════════════════════════════════ */

    var quadVAO = gl.createVertexArray();
    gl.bindVertexArray(quadVAO);
    var quadVBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, -1,1, 1,1, 1,-1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    var quadIBO = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIBO);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);
    gl.bindVertexArray(null);

    function blit(fbo) {
        if (fbo) {
            gl.viewport(0, 0, fbo.width, fbo.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.fbo);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        gl.bindVertexArray(quadVAO);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }

    /* ═══════════════════════════════════════════════════════
       FRAMEBUFFER OBJECTS
       ═══════════════════════════════════════════════════════ */

    function createFBO(w, h, intFmt, fmt, type, filter) {
        gl.activeTexture(gl.TEXTURE0);
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, intFmt, w, h, 0, fmt, type, null);
        var fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return {
            texture: texture, fbo: fbo, width: w, height: h,
            attach: function(unit) {
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                return unit;
            }
        };
    }

    function createDoubleFBO(w, h, intFmt, fmt, type, filter) {
        var fbo1 = createFBO(w, h, intFmt, fmt, type, filter);
        var fbo2 = createFBO(w, h, intFmt, fmt, type, filter);
        return {
            width: w, height: h,
            texelSizeX: 1.0 / w, texelSizeY: 1.0 / h,
            read: fbo1, write: fbo2,
            swap: function() { var t = this.read; this.read = this.write; this.write = t; }
        };
    }

    function resizeFBO(target, w, h, intFmt, fmt, type, filter) {
        var newFBO = createFBO(w, h, intFmt, fmt, type, filter);
        copyProg.bind();
        gl.uniform1i(copyProg.uniforms.uTexture, target.attach(0));
        blit(newFBO);
        return newFBO;
    }

    function resizeDoubleFBO(target, w, h, intFmt, fmt, type, filter) {
        if (target.width === w && target.height === h) return target;
        target.read = resizeFBO(target.read, w, h, intFmt, fmt, type, filter);
        target.write = createFBO(w, h, intFmt, fmt, type, filter);
        target.width = w; target.height = h;
        target.texelSizeX = 1.0 / w; target.texelSizeY = 1.0 / h;
        return target;
    }

    /* ═══════════════════════════════════════════════════════
       SHADER SOURCES
       ═══════════════════════════════════════════════════════ */

    var baseVert = '#version 300 es\n\
precision highp float;\n\
layout(location=0) in vec2 aPosition;\n\
out vec2 vUv;\n\
out vec2 vL, vR, vT, vB;\n\
uniform vec2 texelSize;\n\
void main(){\n\
    vUv = aPosition * 0.5 + 0.5;\n\
    vL = vUv - vec2(texelSize.x, 0.0);\n\
    vR = vUv + vec2(texelSize.x, 0.0);\n\
    vT = vUv + vec2(0.0, texelSize.y);\n\
    vB = vUv - vec2(0.0, texelSize.y);\n\
    gl_Position = vec4(aPosition, 0.0, 1.0);\n\
}';

    var bloomBlurVert = '#version 300 es\n\
precision highp float;\n\
layout(location=0) in vec2 aPosition;\n\
out vec2 vUv;\n\
out vec2 vL, vR;\n\
uniform vec2 texelSize;\n\
void main(){\n\
    vUv = aPosition * 0.5 + 0.5;\n\
    float offset = 1.33333;\n\
    vL = vUv - texelSize * offset;\n\
    vR = vUv + texelSize * offset;\n\
    gl_Position = vec4(aPosition, 0.0, 1.0);\n\
}';

    /* ── Simulation shaders ── */

    var copyFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
out vec4 fragColor;\n\
void main(){ fragColor = texture(uTexture, vUv); }';

    var clearFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform float value;\n\
out vec4 fragColor;\n\
void main(){ fragColor = value * texture(uTexture, vUv); }';

    var splatFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uTarget;\n\
uniform float aspectRatio;\n\
uniform vec3 color;\n\
uniform vec2 point;\n\
uniform float radius;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 p = vUv - point;\n\
    p.x *= aspectRatio;\n\
    vec3 splat = exp(-dot(p,p) / radius) * color;\n\
    vec3 base = texture(uTarget, vUv).xyz;\n\
    fragColor = vec4(base + splat, 1.0);\n\
}';

    var advectionFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uSource;\n\
uniform vec2 texelSize;\n\
uniform float dt;\n\
uniform float dissipation;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 coord = vUv - dt * texture(uVelocity, vUv).xy * texelSize;\n\
    vec3 result = dissipation * texture(uSource, coord).xyz;\n\
    float decay = dissipation < 1.0 ? max(0.0, 1.0 - 0.0002) : 1.0;\n\
    fragColor = vec4(result * decay, 1.0);\n\
}';

    var divergenceFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uVelocity, vL).x;\n\
    float R = texture(uVelocity, vR).x;\n\
    float T = texture(uVelocity, vT).y;\n\
    float B = texture(uVelocity, vB).y;\n\
    fragColor = vec4(0.5 * (R - L + T - B), 0.0, 0.0, 1.0);\n\
}';

    var curlFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uVelocity, vL).y;\n\
    float R = texture(uVelocity, vR).y;\n\
    float T = texture(uVelocity, vT).x;\n\
    float B = texture(uVelocity, vB).x;\n\
    fragColor = vec4(0.5 * (R - L - T + B), 0.0, 0.0, 1.0);\n\
}';

    var vorticityFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uCurl;\n\
uniform float curl;\n\
uniform float dt;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uCurl, vL).x;\n\
    float R = texture(uCurl, vR).x;\n\
    float T = texture(uCurl, vT).x;\n\
    float B = texture(uCurl, vB).x;\n\
    float C = texture(uCurl, vUv).x;\n\
    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n\
    force /= length(force) + 0.0001;\n\
    force *= curl * C;\n\
    force.y *= -1.0;\n\
    vec2 vel = texture(uVelocity, vUv).xy + force * dt;\n\
    fragColor = vec4(clamp(vel, -1000.0, 1000.0), 0.0, 1.0);\n\
}';

    var pressureFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uPressure;\n\
uniform sampler2D uDivergence;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uPressure, vL).x;\n\
    float R = texture(uPressure, vR).x;\n\
    float T = texture(uPressure, vT).x;\n\
    float B = texture(uPressure, vB).x;\n\
    float div = texture(uDivergence, vUv).x;\n\
    fragColor = vec4((L + R + B + T - div) * 0.25, 0.0, 0.0, 1.0);\n\
}';

    var gradSubFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR, vT, vB;\n\
uniform sampler2D uPressure;\n\
uniform sampler2D uVelocity;\n\
out vec4 fragColor;\n\
void main(){\n\
    float L = texture(uPressure, vL).x;\n\
    float R = texture(uPressure, vR).x;\n\
    float T = texture(uPressure, vT).x;\n\
    float B = texture(uPressure, vB).x;\n\
    vec2 vel = texture(uVelocity, vUv).xy - vec2(R - L, T - B);\n\
    fragColor = vec4(vel, 0.0, 1.0);\n\
}';

    /* ── Bloom shaders ── */

    var bloomPrefilterFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
uniform sampler2D uTexture;\n\
uniform vec3 curve;\n\
uniform float threshold;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec3 c = texture(uTexture, vUv).rgb;\n\
    float br = max(c.r, max(c.g, c.b));\n\
    float rq = clamp(br - curve.x, 0.0, curve.y);\n\
    rq = curve.z * rq * rq;\n\
    c *= max(rq, br - threshold) / max(br, 0.0001);\n\
    fragColor = vec4(c, 1.0);\n\
}';

    var bloomBlurFrag = '#version 300 es\n\
precision mediump float;\n\
in vec2 vUv;\n\
in vec2 vL, vR;\n\
uniform sampler2D uTexture;\n\
out vec4 fragColor;\n\
void main(){\n\
    fragColor = texture(uTexture, vL)*0.25 + texture(uTexture, vUv)*0.5 + texture(uTexture, vR)*0.25;\n\
}';

    /* ── Display shaders (3 modes) ── */

    /* LIQUID: video distorted by velocity + dye overlay + bloom */
    var displayLiquidFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uDye;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uVideo;\n\
uniform sampler2D uBloom;\n\
uniform float bloomIntensity;\n\
uniform float distortion;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 vel = texture(uVelocity, vUv).xy;\n\
    vec2 vidUv = vec2(vUv.x, 1.0 - vUv.y);\n\
    vec2 distUv = vidUv + vel * distortion;\n\
    vec3 vid = texture(uVideo, distUv).rgb;\n\
    vec3 dye = texture(uDye, vUv).rgb;\n\
    vec3 bloom = texture(uBloom, vUv).rgb;\n\
    float dyeStr = length(dye);\n\
    vec3 c = vid * (1.0 - dyeStr * 0.35) + dye * 0.8 + bloom * bloomIntensity;\n\
    float a=2.51, b=0.03, d=2.43, e=0.59, f=0.14;\n\
    c = clamp((c*(a*c+b))/(c*(d*c+e)+f), 0.0, 1.0);\n\
    c *= 1.0 - 0.2 * length(vUv - 0.5);\n\
    fragColor = vec4(c, 1.0);\n\
}';

    /* PRISM: chromatic aberration driven by velocity + bloom */
    var displayPrismFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uDye;\n\
uniform sampler2D uVelocity;\n\
uniform sampler2D uVideo;\n\
uniform sampler2D uBloom;\n\
uniform float bloomIntensity;\n\
uniform float distortion;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec2 vel = texture(uVelocity, vUv).xy;\n\
    vec2 vidUv = vec2(vUv.x, 1.0 - vUv.y);\n\
    float r = texture(uVideo, vidUv + vel * distortion * 1.5).r;\n\
    float g = texture(uVideo, vidUv + vel * distortion * 0.6).g;\n\
    float b = texture(uVideo, vidUv + vel * distortion * 0.1).b;\n\
    vec3 dye = texture(uDye, vUv).rgb;\n\
    vec3 bloom = texture(uBloom, vUv).rgb;\n\
    vec3 c = vec3(r, g, b) + dye * 0.5 + bloom * bloomIntensity;\n\
    float a=2.51, bb=0.03, d=2.43, e=0.59, f=0.14;\n\
    c = clamp((c*(a*c+bb))/(c*(d*c+e)+f), 0.0, 1.0);\n\
    c *= 1.0 - 0.2 * length(vUv - 0.5);\n\
    fragColor = vec4(c, 1.0);\n\
}';

    /* INK: pure dye + bloom (no video) */
    var displayInkFrag = '#version 300 es\n\
precision highp float;\n\
in vec2 vUv;\n\
uniform sampler2D uDye;\n\
uniform sampler2D uBloom;\n\
uniform float bloomIntensity;\n\
out vec4 fragColor;\n\
void main(){\n\
    vec3 c = texture(uDye, vUv).rgb;\n\
    vec3 bloom = texture(uBloom, vUv).rgb;\n\
    c += bloom * bloomIntensity;\n\
    float a=2.51, b=0.03, d=2.43, e=0.59, f=0.14;\n\
    c = clamp((c*(a*c+b))/(c*(d*c+e)+f), 0.0, 1.0);\n\
    c *= 1.0 - 0.25 * length(vUv - 0.5);\n\
    fragColor = vec4(c, 1.0);\n\
}';

    /* ═══════════════════════════════════════════════════════
       COMPILE PROGRAMS
       ═══════════════════════════════════════════════════════ */

    var copyProg           = new ShaderProgram(baseVert, copyFrag);
    var clearProg          = new ShaderProgram(baseVert, clearFrag);
    var splatProg          = new ShaderProgram(baseVert, splatFrag);
    var advectionProg      = new ShaderProgram(baseVert, advectionFrag);
    var divergenceProg     = new ShaderProgram(baseVert, divergenceFrag);
    var curlProg           = new ShaderProgram(baseVert, curlFrag);
    var vorticityProg      = new ShaderProgram(baseVert, vorticityFrag);
    var pressureProg       = new ShaderProgram(baseVert, pressureFrag);
    var gradSubProg        = new ShaderProgram(baseVert, gradSubFrag);
    var bloomPrefilterProg = new ShaderProgram(baseVert, bloomPrefilterFrag);
    var bloomBlurProg      = new ShaderProgram(bloomBlurVert, bloomBlurFrag);
    var displayLiquidProg  = new ShaderProgram(baseVert, displayLiquidFrag);
    var displayPrismProg   = new ShaderProgram(baseVert, displayPrismFrag);
    var displayInkProg     = new ShaderProgram(baseVert, displayInkFrag);

    /* ═══════════════════════════════════════════════════════
       INIT FRAMEBUFFERS
       ═══════════════════════════════════════════════════════ */

    var dye, velocity, divergence, curl, pressure;
    var bloomFBOs = [];

    function getResolution(resolution) {
        var aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
        if (aspect < 1) aspect = 1.0 / aspect;
        var mn = Math.round(resolution);
        var mx = Math.round(resolution * aspect);
        return gl.drawingBufferWidth > gl.drawingBufferHeight
            ? { width: mx, height: mn }
            : { width: mn, height: mx };
    }

    function initFramebuffers() {
        var simRes = getResolution(config.SIM_RESOLUTION);
        var dyeRes = getResolution(config.DYE_RESOLUTION);
        var simF = supportLinear ? gl.LINEAR : gl.NEAREST;
        var dyeF = supportLinear ? gl.LINEAR : gl.NEAREST;

        if (!dye) {
            dye = createDoubleFBO(dyeRes.width, dyeRes.height, formatRGBA.internalFormat, formatRGBA.format, texType, dyeF);
        } else {
            dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, formatRGBA.internalFormat, formatRGBA.format, texType, dyeF);
        }
        if (!velocity) {
            velocity = createDoubleFBO(simRes.width, simRes.height, formatRG.internalFormat, formatRG.format, texType, simF);
        } else {
            velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, formatRG.internalFormat, formatRG.format, texType, simF);
        }
        divergence = createFBO(simRes.width, simRes.height, formatR.internalFormat, formatR.format, texType, gl.NEAREST);
        curl = createFBO(simRes.width, simRes.height, formatR.internalFormat, formatR.format, texType, gl.NEAREST);
        pressure = createDoubleFBO(simRes.width, simRes.height, formatR.internalFormat, formatR.format, texType, gl.NEAREST);
        initBloomFBOs();
    }

    function initBloomFBOs() {
        var res = getResolution(config.BLOOM_RESOLUTION);
        var filter = supportLinear ? gl.LINEAR : gl.NEAREST;
        bloomFBOs.length = 0;
        for (var i = 0; i < config.BLOOM_ITERATIONS; i++) {
            var w = res.width >> (i + 1);
            var h = res.height >> (i + 1);
            if (w < 2 || h < 2) break;
            bloomFBOs.push(createFBO(w, h, formatRGBA.internalFormat, formatRGBA.format, texType, filter));
        }
    }

    initFramebuffers();

    /* ═══════════════════════════════════════════════════════
       RESIZE
       ═══════════════════════════════════════════════════════ */

    function resizeCanvas() {
        var w = window.innerWidth, h = window.innerHeight;
        if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w; canvas.height = h;
            initFramebuffers();
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas, { passive: true });

    /* ═══════════════════════════════════════════════════════
       SIMULATION
       ═══════════════════════════════════════════════════════ */

    function step(dt) {
        gl.disable(gl.BLEND);

        curlProg.bind();
        gl.uniform2f(curlProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(curlProg.uniforms.uVelocity, velocity.read.attach(0));
        blit(curl);

        vorticityProg.bind();
        gl.uniform2f(vorticityProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(vorticityProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(vorticityProg.uniforms.uCurl, curl.attach(1));
        gl.uniform1f(vorticityProg.uniforms.curl, config.CURL);
        gl.uniform1f(vorticityProg.uniforms.dt, dt);
        blit(velocity.write);
        velocity.swap();

        divergenceProg.bind();
        gl.uniform2f(divergenceProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(divergenceProg.uniforms.uVelocity, velocity.read.attach(0));
        blit(divergence);

        clearProg.bind();
        gl.uniform1i(clearProg.uniforms.uTexture, pressure.read.attach(0));
        gl.uniform1f(clearProg.uniforms.value, config.PRESSURE);
        blit(pressure.write);
        pressure.swap();

        pressureProg.bind();
        gl.uniform2f(pressureProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(pressureProg.uniforms.uDivergence, divergence.attach(0));
        for (var i = 0; i < config.PRESSURE_ITERATIONS; i++) {
            gl.uniform1i(pressureProg.uniforms.uPressure, pressure.read.attach(1));
            blit(pressure.write);
            pressure.swap();
        }

        gradSubProg.bind();
        gl.uniform2f(gradSubProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(gradSubProg.uniforms.uPressure, pressure.read.attach(0));
        gl.uniform1i(gradSubProg.uniforms.uVelocity, velocity.read.attach(1));
        blit(velocity.write);
        velocity.swap();

        advectionProg.bind();
        gl.uniform2f(advectionProg.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
        gl.uniform1i(advectionProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(advectionProg.uniforms.uSource, velocity.read.attach(0));
        gl.uniform1f(advectionProg.uniforms.dt, dt);
        gl.uniform1f(advectionProg.uniforms.dissipation, config.VELOCITY_DISSIPATION);
        blit(velocity.write);
        velocity.swap();

        gl.uniform2f(advectionProg.uniforms.texelSize, dye.texelSizeX, dye.texelSizeY);
        gl.uniform1i(advectionProg.uniforms.uVelocity, velocity.read.attach(0));
        gl.uniform1i(advectionProg.uniforms.uSource, dye.read.attach(1));
        gl.uniform1f(advectionProg.uniforms.dissipation, config.DENSITY_DISSIPATION);
        blit(dye.write);
        dye.swap();
    }

    /* ═══════════════════════════════════════════════════════
       BLOOM
       ═══════════════════════════════════════════════════════ */

    function applyBloom(source) {
        if (bloomFBOs.length < 2) return;
        var last = bloomFBOs[0];
        var knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;

        bloomPrefilterProg.bind();
        gl.uniform1i(bloomPrefilterProg.uniforms.uTexture, source.attach(0));
        gl.uniform3f(bloomPrefilterProg.uniforms.curve,
            config.BLOOM_THRESHOLD - knee, knee * 2.0, 0.25 / knee);
        gl.uniform1f(bloomPrefilterProg.uniforms.threshold, config.BLOOM_THRESHOLD);
        blit(last);

        bloomBlurProg.bind();
        for (var i = 1; i < bloomFBOs.length; i++) {
            var dest = bloomFBOs[i];
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 1.0 / last.width, 0.0);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, last.attach(0));
            blit(dest);
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 0.0, 1.0 / dest.height);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, dest.attach(0));
            blit(dest);
            last = dest;
        }

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        for (var i = bloomFBOs.length - 2; i >= 0; i--) {
            var dest = bloomFBOs[i];
            gl.uniform2f(bloomBlurProg.uniforms.texelSize, 1.0 / last.width, 0.0);
            gl.uniform1i(bloomBlurProg.uniforms.uTexture, last.attach(0));
            blit(dest);
            last = dest;
        }
        gl.disable(gl.BLEND);
    }

    /* ═══════════════════════════════════════════════════════
       RENDER
       ═══════════════════════════════════════════════════════ */

    function render() {
        var bloomI = config.BLOOM ? config.BLOOM_INTENSITY : 0.0;
        if (config.BLOOM) applyBloom(dye.read);

        updateVideoTexture();

        var mode = config.MODE;
        if (mode === 'liquid') {
            displayLiquidProg.bind();
            gl.uniform1i(displayLiquidProg.uniforms.uDye, dye.read.attach(0));
            gl.uniform1i(displayLiquidProg.uniforms.uVelocity, velocity.read.attach(1));
            gl.uniform1i(displayLiquidProg.uniforms.uVideo, attachVideoTexture(2));
            gl.uniform1i(displayLiquidProg.uniforms.uBloom, bloomFBOs.length > 0 ? bloomFBOs[0].attach(3) : dye.read.attach(3));
            gl.uniform1f(displayLiquidProg.uniforms.bloomIntensity, bloomI);
            gl.uniform1f(displayLiquidProg.uniforms.distortion, config.DISTORTION);
        } else if (mode === 'prism') {
            displayPrismProg.bind();
            gl.uniform1i(displayPrismProg.uniforms.uDye, dye.read.attach(0));
            gl.uniform1i(displayPrismProg.uniforms.uVelocity, velocity.read.attach(1));
            gl.uniform1i(displayPrismProg.uniforms.uVideo, attachVideoTexture(2));
            gl.uniform1i(displayPrismProg.uniforms.uBloom, bloomFBOs.length > 0 ? bloomFBOs[0].attach(3) : dye.read.attach(3));
            gl.uniform1f(displayPrismProg.uniforms.bloomIntensity, bloomI);
            gl.uniform1f(displayPrismProg.uniforms.distortion, config.DISTORTION);
        } else {
            displayInkProg.bind();
            gl.uniform1i(displayInkProg.uniforms.uDye, dye.read.attach(0));
            gl.uniform1i(displayInkProg.uniforms.uBloom, bloomFBOs.length > 0 ? bloomFBOs[0].attach(1) : dye.read.attach(1));
            gl.uniform1f(displayInkProg.uniforms.bloomIntensity, bloomI);
        }
        blit(null);
    }

    /* ═══════════════════════════════════════════════════════
       SPLATS
       ═══════════════════════════════════════════════════════ */

    function splat(x, y, dx, dy, color) {
        splatProg.bind();
        gl.uniform1i(splatProg.uniforms.uTarget, velocity.read.attach(0));
        gl.uniform1f(splatProg.uniforms.aspectRatio, canvas.width / canvas.height);
        gl.uniform2f(splatProg.uniforms.point, x, y);
        gl.uniform3f(splatProg.uniforms.color, dx, dy, 0.0);
        gl.uniform1f(splatProg.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
        blit(velocity.write);
        velocity.swap();

        gl.uniform1i(splatProg.uniforms.uTarget, dye.read.attach(0));
        gl.uniform3f(splatProg.uniforms.color, color.r, color.g, color.b);
        blit(dye.write);
        dye.swap();
    }

    function correctRadius(r) {
        var a = canvas.width / canvas.height;
        return a > 1 ? r * a : r;
    }

    function generateColor() {
        var p = PALETTES[config.PALETTE];
        if (p) {
            var c = p[Math.floor(Math.random() * p.length)];
            return { r: c[0] * 0.15, g: c[1] * 0.15, b: c[2] * 0.15 };
        }
        var c = HSVtoRGB(Math.random(), 1.0, 1.0);
        return { r: c.r * 0.15, g: c.g * 0.15, b: c.b * 0.15 };
    }

    function HSVtoRGB(h, s, v) {
        var i = Math.floor(h * 6), f = h * 6 - i;
        var p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
        var r, g, b;
        switch (i % 6) {
            case 0: r=v;g=t;b=p; break; case 1: r=q;g=v;b=p; break;
            case 2: r=p;g=v;b=t; break; case 3: r=p;g=q;b=v; break;
            case 4: r=t;g=p;b=v; break; case 5: r=v;g=p;b=q; break;
        }
        return { r: r, g: g, b: b };
    }

    /* ═══════════════════════════════════════════════════════
       INPUT
       ═══════════════════════════════════════════════════════ */

    var pointers = [];
    var hintEl = document.getElementById('hint');
    var hintDismissed = false;

    function Pointer() {
        this.id = -1;
        this.texX = 0; this.texY = 0;
        this.prevTexX = 0; this.prevTexY = 0;
        this.deltaX = 0; this.deltaY = 0;
        this.down = false; this.moved = false;
        this.color = generateColor();
    }
    pointers.push(new Pointer());

    function getPointerById(id) {
        for (var i = 0; i < pointers.length; i++)
            if (pointers[i].id === id) return pointers[i];
        return null;
    }

    function ptrDown(ptr, id, x, y) {
        ptr.id = id; ptr.down = true; ptr.moved = false;
        ptr.texX = x / canvas.width; ptr.texY = 1.0 - y / canvas.height;
        ptr.prevTexX = ptr.texX; ptr.prevTexY = ptr.texY;
        ptr.color = generateColor();
    }

    function ptrMove(ptr, x, y) {
        ptr.prevTexX = ptr.texX; ptr.prevTexY = ptr.texY;
        ptr.texX = x / canvas.width; ptr.texY = 1.0 - y / canvas.height;
        ptr.deltaX = ptr.texX - ptr.prevTexX;
        ptr.deltaY = ptr.texY - ptr.prevTexY;
        ptr.moved = Math.abs(ptr.deltaX) > 0 || Math.abs(ptr.deltaY) > 0;
        if (!hintDismissed && ptr.moved) { hintDismissed = true; hintEl.classList.add('hidden'); }
    }

    canvas.addEventListener('mousedown', function(e) { ptrDown(pointers[0], -1, e.offsetX, e.offsetY); });
    canvas.addEventListener('mousemove', function(e) {
        pointers[0].down = (e.buttons & 1) !== 0;
        ptrMove(pointers[0], e.offsetX, e.offsetY);
    });
    canvas.addEventListener('mouseup', function() { pointers[0].down = false; });

    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        for (var i = 0; i < e.changedTouches.length; i++) {
            var t = e.changedTouches[i];
            var ptr = getPointerById(t.identifier);
            if (!ptr) { ptr = new Pointer(); pointers.push(ptr); }
            ptrDown(ptr, t.identifier, t.clientX, t.clientY);
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        for (var i = 0; i < e.changedTouches.length; i++) {
            var t = e.changedTouches[i];
            var ptr = getPointerById(t.identifier);
            if (ptr) ptrMove(ptr, t.clientX, t.clientY);
        }
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
        for (var i = 0; i < e.changedTouches.length; i++) {
            var ptr = getPointerById(e.changedTouches[i].identifier);
            if (ptr) ptr.down = false;
        }
    });

    /* ═══════════════════════════════════════════════════════
       AUTO-SPLAT
       ═══════════════════════════════════════════════════════ */

    var autoSplatTimer = 0, attractTime = 0;

    function autoSplat(dt) {
        autoSplatTimer += dt;
        attractTime += dt;
        if (autoSplatTimer < config.AUTO_SPLAT_INTERVAL / 1000) return;
        autoSplatTimer = 0;

        var t = attractTime;
        var x = 0.5 + 0.35 * Math.sin(t * 0.7 + 1.2);
        var y = 0.5 + 0.35 * Math.cos(t * 0.5 + 0.8);
        splat(x, y, 500 * Math.cos(t * 1.3), 500 * Math.sin(t * 0.9), generateColor());

        if (Math.random() < 0.12) {
            var cx = 0.3 + Math.random() * 0.4, cy = 0.3 + Math.random() * 0.4;
            var n = 5 + Math.floor(Math.random() * 7);
            for (var i = 0; i < n; i++) {
                var a = (i / n) * Math.PI * 2;
                var r = 0.03 + Math.random() * 0.06;
                splat(cx + Math.cos(a) * r, cy + Math.sin(a) * r,
                    Math.cos(a) * 1200, Math.sin(a) * 1200, generateColor());
            }
        }
    }

    function triggerBurst() {
        var cx = 0.3 + Math.random() * 0.4, cy = 0.3 + Math.random() * 0.4;
        var n = 8 + Math.floor(Math.random() * 8);
        for (var i = 0; i < n; i++) {
            var a = (i / n) * Math.PI * 2 + Math.random() * 0.3;
            var r = 0.04 + Math.random() * 0.08;
            var f = 800 + Math.random() * 1600;
            splat(cx + Math.cos(a) * r, cy + Math.sin(a) * r,
                Math.cos(a) * f, Math.sin(a) * f, generateColor());
        }
    }

    /* ═══════════════════════════════════════════════════════
       MAIN LOOP
       ═══════════════════════════════════════════════════════ */

    var lastTime = performance.now();

    function frame(now) {
        var dt = Math.min((now - lastTime) / 1000, 0.016667);
        lastTime = now;
        resizeCanvas();

        for (var i = 0; i < pointers.length; i++) {
            var p = pointers[i];
            if (p.moved) {
                p.moved = false;
                splat(p.texX, p.texY, p.deltaX * config.SPLAT_FORCE, p.deltaY * config.SPLAT_FORCE, p.color);
            }
            if (p.down) p.color = generateColor();
        }

        autoSplat(dt);
        step(dt);
        render();
        requestAnimationFrame(frame);
    }

    /* Initial splash */
    (function() {
        var n = 5 + Math.floor(Math.random() * 5);
        for (var i = 0; i < n; i++) {
            var a = Math.random() * Math.PI * 2;
            var f = 400 + Math.random() * 800;
            splat(0.15 + Math.random() * 0.7, 0.15 + Math.random() * 0.7,
                Math.cos(a) * f, Math.sin(a) * f, generateColor());
        }
    })();

    requestAnimationFrame(frame);

    /* ═══════════════════════════════════════════════════════
       UI CONTROLS
       ═══════════════════════════════════════════════════════ */

    /* Mode buttons */
    var modeBtns = document.querySelectorAll('.mode-btn');
    modeBtns.forEach(function(btn) {
        btn.addEventListener('click', function() {
            modeBtns.forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            config.MODE = btn.dataset.mode;
        });
    });

    /* Bloom toggle */
    var btnBloom = document.getElementById('btnBloom');
    btnBloom.addEventListener('click', function() {
        config.BLOOM = !config.BLOOM;
        btnBloom.classList.toggle('active', config.BLOOM);
    });

    /* Burst */
    document.getElementById('btnBurst').addEventListener('click', triggerBurst);

    /* Reset */
    document.getElementById('btnReset').addEventListener('click', function() {
        [dye.read, dye.write, velocity.read, velocity.write, pressure.read, pressure.write].forEach(function(fb) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb.fbo);
            gl.clear(gl.COLOR_BUFFER_BIT);
        });
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    });

    /* Keyboard */
    document.addEventListener('keydown', function(e) {
        if (e.key === ' ') { e.preventDefault(); triggerBurst(); }
        if (e.key === 'r') document.getElementById('btnReset').click();
        if (e.key === 'b') btnBloom.click();
        if (e.key === '1') modeBtns[0].click();
        if (e.key === '2') modeBtns[1].click();
        if (e.key === '3') modeBtns[2].click();
    });

    /* Reduced motion */
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        config.AUTO_SPLAT_INTERVAL = 99999999;
    }
    </script>
</body>
</html>
